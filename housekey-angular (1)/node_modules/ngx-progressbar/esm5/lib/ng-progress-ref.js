/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import * as tslib_1 from "tslib";
import { Subject, BehaviorSubject, timer, of, combineLatest, Subscription, EMPTY } from 'rxjs';
import { tap, delay, debounce, switchMap, takeUntil, finalize, filter } from 'rxjs/operators';
var NgProgressRef = /** @class */ (function () {
    function NgProgressRef(customConfig, _onDestroyCallback) {
        var _this = this;
        this._onDestroyCallback = _onDestroyCallback;
        // Progress start source event (used to cancel finalizing delays)
        this._started = new Subject();
        // Progress start event: stream that emits only when it hasn't already started
        this.started = this._started.pipe(filter((/**
         * @return {?}
         */
        function () { return !_this.isStarted; })));
        // Progress ended source event
        this._completed = new Subject();
        // Progress start event: stream that emits only when it has already started
        this.completed = this._completed.pipe(filter((/**
         * @return {?}
         */
        function () { return _this.isStarted; })));
        // Stream that increments and updates the progress state
        this._trickling = new Subject();
        // Stream that combines "_trickling" and "config" streams
        this._worker = Subscription.EMPTY;
        this._state = new BehaviorSubject({ active: false, value: 0 });
        this._config = new BehaviorSubject(customConfig);
        this.state = this._state.asObservable();
        this.config = this._state.asObservable();
        this._worker = combineLatest(this._trickling, this._config).pipe(debounce((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _b = tslib_1.__read(_a, 2), start = _b[0], config = _b[1];
            return timer(start ? config.debounceTime : 0);
        })), switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        function (_a) {
            var _b = tslib_1.__read(_a, 2), start = _b[0], config = _b[1];
            return start ? _this.onTrickling(config) : _this.onComplete(config);
        }))).subscribe();
    }
    Object.defineProperty(NgProgressRef.prototype, "currState", {
        // Get current progress state
        get: 
        // Get current progress state
        /**
         * @private
         * @return {?}
         */
        function () {
            return this._state.value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NgProgressRef.prototype, "isStarted", {
        // Check if progress has started
        get: 
        // Check if progress has started
        /**
         * @return {?}
         */
        function () {
            return this.currState.active;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Start the progress
     */
    /**
     * Start the progress
     * @return {?}
     */
    NgProgressRef.prototype.start = /**
     * Start the progress
     * @return {?}
     */
    function () {
        this._started.next();
        this._trickling.next(true);
    };
    /**
     * Complete the progress
     */
    /**
     * Complete the progress
     * @return {?}
     */
    NgProgressRef.prototype.complete = /**
     * Complete the progress
     * @return {?}
     */
    function () {
        this._trickling.next(false);
    };
    /**
     * Increment the progress
     */
    /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    NgProgressRef.prototype.inc = /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    function (amount) {
        /** @type {?} */
        var n = this.currState.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.value.trickleFunc(n);
            }
            this.set(n + amount);
        }
    };
    /**
     * Set the progress
     */
    /**
     * Set the progress
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.set = /**
     * Set the progress
     * @param {?} n
     * @return {?}
     */
    function (n) {
        this.setState({ value: this.clamp(n), active: true });
    };
    /**
     * Set config
     */
    /**
     * Set config
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.setConfig = /**
     * Set config
     * @param {?} config
     * @return {?}
     */
    function (config) {
        this._config.next(tslib_1.__assign({}, this._config.value, config));
    };
    /**
     * Destroy progress reference
     */
    /**
     * Destroy progress reference
     * @return {?}
     */
    NgProgressRef.prototype.destroy = /**
     * Destroy progress reference
     * @return {?}
     */
    function () {
        this._worker.unsubscribe();
        this._trickling.complete();
        this._state.complete();
        this._config.complete();
        this._started.complete();
        this._completed.complete();
        this._onDestroyCallback();
    };
    /**
     * Set progress state
     */
    /**
     * Set progress state
     * @private
     * @param {?} state
     * @return {?}
     */
    NgProgressRef.prototype.setState = /**
     * Set progress state
     * @private
     * @param {?} state
     * @return {?}
     */
    function (state) {
        this._state.next(tslib_1.__assign({}, this.currState, state));
    };
    /**
     * Clamps a value to be between min and max
     */
    /**
     * Clamps a value to be between min and max
     * @private
     * @param {?} n
     * @return {?}
     */
    NgProgressRef.prototype.clamp = /**
     * Clamps a value to be between min and max
     * @private
     * @param {?} n
     * @return {?}
     */
    function (n) {
        return Math.max(this._config.value.min, Math.min(this._config.value.max, n));
    };
    /**
     * Keeps incrementing the progress
     */
    /**
     * Keeps incrementing the progress
     * @private
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.onTrickling = /**
     * Keeps incrementing the progress
     * @private
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        if (!this.isStarted) {
            this.set(this._config.value.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap((/**
         * @return {?}
         */
        function () { return _this.inc(); })));
    };
    /**
     * Completes then resets the progress
     */
    /**
     * Completes then resets the progress
     * @private
     * @param {?} config
     * @return {?}
     */
    NgProgressRef.prototype.onComplete = /**
     * Completes then resets the progress
     * @private
     * @param {?} config
     * @return {?}
     */
    function (config) {
        var _this = this;
        this._completed.next();
        return !this.isStarted ? EMPTY : of({}).pipe(
        // Complete the progress
        tap((/**
         * @return {?}
         */
        function () { return _this.setState({ value: 100 }); })), 
        // Deactivate the progress after a tiny delay
        delay(config.speed * 1.7), tap((/**
         * @return {?}
         */
        function () { return _this.setState({ active: false }); })), 
        // Use a tiny delay before resetting
        delay(config.speed), 
        // Force the progress to reset even it got cancelled
        finalize((/**
         * @return {?}
         */
        function () { return _this.setState({ value: 0 }); })), 
        // Cancel any of the finalizing delays if the progress has started again
        takeUntil(this._started));
    };
    return NgProgressRef;
}());
export { NgProgressRef };
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._state;
    /** @type {?} */
    NgProgressRef.prototype.state;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._config;
    /** @type {?} */
    NgProgressRef.prototype.config;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._started;
    /** @type {?} */
    NgProgressRef.prototype.started;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._completed;
    /** @type {?} */
    NgProgressRef.prototype.completed;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._trickling;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._worker;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._onDestroyCallback;
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibmctcHJvZ3Jlc3MtcmVmLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXByb2dyZXNzYmFyLyIsInNvdXJjZXMiOlsibGliL25nLXByb2dyZXNzLXJlZi50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFBYyxPQUFPLEVBQUUsZUFBZSxFQUFFLEtBQUssRUFBRSxFQUFFLEVBQUUsYUFBYSxFQUFFLFlBQVksRUFBRSxLQUFLLEVBQUUsTUFBTSxNQUFNLENBQUM7QUFDM0csT0FBTyxFQUFFLEdBQUcsRUFBRSxLQUFLLEVBQUUsUUFBUSxFQUFFLFNBQVMsRUFBRSxTQUFTLEVBQUUsUUFBUSxFQUFFLE1BQU0sRUFBRSxNQUFNLGdCQUFnQixDQUFDO0FBRzlGO0lBb0NFLHVCQUFZLFlBQThCLEVBQVUsa0JBQThCO1FBQWxGLGlCQVVDO1FBVm1ELHVCQUFrQixHQUFsQixrQkFBa0IsQ0FBWTs7UUF6QmpFLGFBQVEsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDOztRQUVqQyxZQUFPLEdBQUcsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQUMsTUFBTTs7O1FBQUMsY0FBTSxPQUFBLENBQUMsS0FBSSxDQUFDLFNBQVMsRUFBZixDQUFlLEVBQUMsQ0FBQyxDQUFDOztRQUdwRCxlQUFVLEdBQUcsSUFBSSxPQUFPLEVBQUUsQ0FBQzs7UUFFbkMsY0FBUyxHQUFHLElBQUksQ0FBQyxVQUFVLENBQUMsSUFBSSxDQUFDLE1BQU07OztRQUFDLGNBQU0sT0FBQSxLQUFJLENBQUMsU0FBUyxFQUFkLENBQWMsRUFBQyxDQUFDLENBQUM7O1FBR3ZELGVBQVUsR0FBRyxJQUFJLE9BQU8sRUFBRSxDQUFDOztRQUczQixZQUFPLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQztRQWE1QyxJQUFJLENBQUMsTUFBTSxHQUFHLElBQUksZUFBZSxDQUFrQixFQUFFLE1BQU0sRUFBRSxLQUFLLEVBQUUsS0FBSyxFQUFFLENBQUMsRUFBRSxDQUFDLENBQUM7UUFDaEYs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Q0FBc0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPYnNlcnZhYmxlLCBTdWJqZWN0LCBCZWhhdmlvclN1YmplY3QsIHRpbWVyLCBvZiwgY29tYmluZUxhdGVzdCwgU3Vic2NyaXB0aW9uLCBFTVBUWSB9IGZyb20gJ3J4anMnO1xyXG5pbXBvcnQgeyB0YXAsIGRlbGF5LCBkZWJvdW5jZSwgc3dpdGNoTWFwLCB0YWtlVW50aWwsIGZpbmFsaXplLCBmaWx0ZXIgfSBmcm9tICdyeGpzL29wZXJhdG9ycyc7XHJcbmltcG9ydCB7IE5nUHJvZ3Jlc3NTdGF0ZSwgTmdQcm9ncmVzc0NvbmZpZyB9IGZyb20gJy4vbmctcHJvZ3Jlc3MuaW50ZXJmYWNlJztcclxuXHJcbmV4cG9ydCBjbGFzcyBOZ1Byb2dyZXNzUmVmIHtcclxuXHJcbiAgLy8gU3RyZWFtIHRoYXQgZW1pdHMgd2hlbiBwcm9ncmVzcyBzdGF0ZSBpcyBjaGFuZ2VkXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfc3RhdGU6IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzU3RhdGU+O1xyXG4gIHN0YXRlOiBPYnNlcnZhYmxlPE5nUHJvZ3Jlc3NTdGF0ZT47XHJcblxyXG4gIC8vIFN0cmVhbSB0aGF0IGVtaXRzIHdoZW4gY29uZmlnIGlzIGNoYW5nZWRcclxuICBwcml2YXRlIHJlYWRvbmx5IF9jb25maWc6IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzQ29uZmlnPjtcclxuICBjb25maWc6IE9ic2VydmFibGU8TmdQcm9ncmVzc1N0YXRlPjtcclxuXHJcbiAgLy8gUHJvZ3Jlc3Mgc3RhcnQgc291cmNlIGV2ZW50ICh1c2VkIHRvIGNhbmNlbCBmaW5hbGl6aW5nIGRlbGF5cylcclxuICBwcml2YXRlIHJlYWRvbmx5IF9zdGFydGVkID0gbmV3IFN1YmplY3QoKTtcclxuICAvLyBQcm9ncmVzcyBzdGFydCBldmVudDogc3RyZWFtIHRoYXQgZW1pdHMgb25seSB3aGVuIGl0IGhhc24ndCBhbHJlYWR5IHN0YXJ0ZWRcclxuICByZWFkb25seSBzdGFydGVkID0gdGhpcy5fc3RhcnRlZC5waXBlKGZpbHRlcigoKSA9PiAhdGhpcy5pc1N0YXJ0ZWQpKTtcclxuXHJcbiAgLy8gUHJvZ3Jlc3MgZW5kZWQgc291cmNlIGV2ZW50XHJcbiAgcHJpdmF0ZSByZWFkb25seSBfY29tcGxldGVkID0gbmV3IFN1YmplY3QoKTtcclxuICAvLyBQcm9ncmVzcyBzdGFydCBldmVudDogc3RyZWFtIHRoYXQgZW1pdHMgb25seSB3aGVuIGl0IGhhcyBhbHJlYWR5IHN0YXJ0ZWRcclxuICByZWFkb25seSBjb21wbGV0ZWQgPSB0aGlzLl9jb21wbGV0ZWQucGlwZShmaWx0ZXIoKCkgPT4gdGhpcy5pc1N0YXJ0ZWQpKTtcclxuXHJcbiAgLy8gU3RyZWFtIHRoYXQgaW5jcmVtZW50cyBhbmQgdXBkYXRlcyB0aGUgcHJvZ3Jlc3Mgc3RhdGVcclxuICBwcml2YXRlIHJlYWRvbmx5IF90cmlja2xpbmcgPSBuZXcgU3ViamVjdCgpO1xyXG5cclxuICAvLyBTdHJlYW0gdGhhdCBjb21iaW5lcyBcIl90cmlja2xpbmdcIiBhbmQgXCJjb25maWdcIiBzdHJlYW1zXHJcbiAgcHJpdmF0ZSByZWFkb25seSBfd29ya2VyID0gU3Vic2NyaXB0aW9uLkVNUFRZO1xyXG5cclxuICAvLyBHZXQgY3VycmVudCBwcm9ncmVzcyBzdGF0ZVxyXG4gIHByaXZhdGUgZ2V0IGN1cnJTdGF0ZSgpOiBOZ1Byb2dyZXNzU3RhdGUge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXRlLnZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLy8gQ2hlY2sgaWYgcHJvZ3Jlc3MgaGFzIHN0YXJ0ZWRcclxuICBnZXQgaXNTdGFydGVkKCk6IGJvb2xlYW4ge1xyXG4gICAgcmV0dXJuIHRoaXMuY3VyclN0YXRlLmFjdGl2ZTtcclxuICB9XHJcblxyXG4gIGNvbnN0cnVjdG9yKGN1c3RvbUNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZywgcHJpdmF0ZSBfb25EZXN0cm95Q2FsbGJhY2s6ICgpID0+IHZvaWQpIHtcclxuICAgIHRoaXMuX3N0YXRlID0gbmV3IEJlaGF2aW9yU3ViamVjdDxOZ1Byb2dyZXNzU3RhdGU+KHsgYWN0aXZlOiBmYWxzZSwgdmFsdWU6IDAgfSk7XHJcbiAgICB0aGlzLl9jb25maWcgPSBuZXcgQmVoYXZpb3JTdWJqZWN0PE5nUHJvZ3Jlc3NDb25maWc+KGN1c3RvbUNvbmZpZyk7XHJcbiAgICB0aGlzLnN0YXRlID0gdGhpcy5fc3RhdGUuYXNPYnNlcnZhYmxlKCk7XHJcbiAgICB0aGlzLmNvbmZpZyA9IHRoaXMuX3N0YXRlLmFzT2JzZXJ2YWJsZSgpO1xyXG5cclxuICAgIHRoaXMuX3dvcmtlciA9IGNvbWJpbmVMYXRlc3QodGhpcy5fdHJpY2tsaW5nLCB0aGlzLl9jb25maWcpLnBpcGUoXHJcbiAgICAgIGRlYm91bmNlKChbc3RhcnQsIGNvbmZpZ106IFtib29sZWFuLCBOZ1Byb2dyZXNzQ29uZmlnXSkgPT4gdGltZXIoc3RhcnQgPyBjb25maWcuZGVib3VuY2VUaW1lIDogMCkpLFxyXG4gICAgICBzd2l0Y2hNYXAoKFtzdGFydCwgY29uZmlnXTogW2Jvb2xlYW4sIE5nUHJvZ3Jlc3NDb25maWddKSA9PiBzdGFydCA/IHRoaXMub25Ucmlja2xpbmcoY29uZmlnKSA6IHRoaXMub25Db21wbGV0ZShjb25maWcpKVxyXG4gICAgKS5zdWJzY3JpYmUoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHRoZSBwcm9ncmVzc1xyXG4gICAqL1xyXG4gIHN0YXJ0KCkge1xyXG4gICAgdGhpcy5fc3RhcnRlZC5uZXh0KCk7XHJcbiAgICB0aGlzLl90cmlja2xpbmcubmV4dCh0cnVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENvbXBsZXRlIHRoZSBwcm9ncmVzc1xyXG4gICAqL1xyXG4gIGNvbXBsZXRlKCkge1xyXG4gICAgdGhpcy5fdHJpY2tsaW5nLm5leHQoZmFsc2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5jcmVtZW50IHRoZSBwcm9ncmVzc1xyXG4gICAqL1xyXG4gIGluYyhhbW91bnQ/OiBudW1iZXIpIHtcclxuICAgIGNvbnN0IG4gPSB0aGlzLmN1cnJTdGF0ZS52YWx1ZTtcclxuICAgIGlmICghdGhpcy5pc1N0YXJ0ZWQpIHtcclxuICAgICAgdGhpcy5zdGFydCgpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgaWYgKHR5cGVvZiBhbW91bnQgIT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgYW1vdW50ID0gdGhpcy5fY29uZmlnLnZhbHVlLnRyaWNrbGVGdW5jKG4pO1xyXG4gICAgICB9XHJcbiAgICAgIHRoaXMuc2V0KG4gKyBhbW91bnQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBwcm9ncmVzc1xyXG4gICAqL1xyXG4gIHNldChuOiBudW1iZXIpIHtcclxuICAgIHRoaXMuc2V0U3RhdGUoeyB2YWx1ZTogdGhpcy5jbGFtcChuKSwgYWN0aXZlOiB0cnVlIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGNvbmZpZ1xyXG4gICAqL1xyXG4gIHNldENvbmZpZyhjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpIHtcclxuICAgIHRoaXMuX2NvbmZpZy5uZXh0KHsgLi4udGhpcy5fY29uZmlnLnZhbHVlLCAuLi5jb25maWcgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZXN0cm95IHByb2dyZXNzIHJlZmVyZW5jZVxyXG4gICAqL1xyXG4gIGRlc3Ryb3koKSB7XHJcbiAgICB0aGlzLl93b3JrZXIudW5zdWJzY3JpYmUoKTtcclxuICAgIHRoaXMuX3RyaWNrbGluZy5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5fc3RhdGUuY29tcGxldGUoKTtcclxuICAgIHRoaXMuX2NvbmZpZy5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5fc3RhcnRlZC5jb21wbGV0ZSgpO1xyXG4gICAgdGhpcy5fY29tcGxldGVkLmNvbXBsZXRlKCk7XHJcbiAgICB0aGlzLl9vbkRlc3Ryb3lDYWxsYmFjaygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHByb2dyZXNzIHN0YXRlXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBzZXRTdGF0ZShzdGF0ZTogTmdQcm9ncmVzc1N0YXRlKSB7XHJcbiAgICB0aGlzLl9zdGF0ZS5uZXh0KHsgLi4udGhpcy5jdXJyU3RhdGUsIC4uLnN0YXRlIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xhbXBzIGEgdmFsdWUgdG8gYmUgYmV0d2VlbiBtaW4gYW5kIG1heFxyXG4gICAqL1xyXG4gIHByaXZhdGUgY2xhbXAobjogbnVtYmVyKTogbnVtYmVyIHtcclxuICAgIHJldHVybiBNYXRoLm1heCh0aGlzLl9jb25maWcudmFsdWUubWluLCBNYXRoLm1pbih0aGlzLl9jb25maWcudmFsdWUubWF4LCBuKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBLZWVwcyBpbmNyZW1lbnRpbmcgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBvblRyaWNrbGluZyhjb25maWc6IE5nUHJvZ3Jlc3NDb25maWcpOiBPYnNlcnZhYmxlPG51bWJlcj4ge1xyXG4gICAgaWYgKCF0aGlzLmlzU3RhcnRlZCkge1xyXG4gICAgICB0aGlzLnNldCh0aGlzLl9jb25maWcudmFsdWUubWluKTtcclxuICAgIH1cclxuICAgIHJldHVybiB0aW1lcigwLCBjb25maWcudHJpY2tsZVNwZWVkKS5waXBlKHRhcCgoKSA9PiB0aGlzLmluYygpKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDb21wbGV0ZXMgdGhlbiByZXNldHMgdGhlIHByb2dyZXNzXHJcbiAgICovXHJcbiAgcHJpdmF0ZSBvbkNvbXBsZXRlKGNvbmZpZzogTmdQcm9ncmVzc0NvbmZpZyk6IE9ic2VydmFibGU8YW55PiB7XHJcbiAgICB0aGlzLl9jb21wbGV0ZWQubmV4dCgpO1xyXG4gICAgcmV0dXJuICF0aGlzLmlzU3RhcnRlZCA/IEVNUFRZIDogb2Yoe30pLnBpcGUoXHJcbiAgICAgIC8vIENvbXBsZXRlIHRoZSBwcm9ncmVzc1xyXG4gICAgICB0YXAoKCkgPT4gdGhpcy5zZXRTdGF0ZSh7IHZhbHVlOiAxMDAgfSkpLFxyXG5cclxuICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgcHJvZ3Jlc3MgYWZ0ZXIgYSB0aW55IGRlbGF5XHJcbiAgICAgIGRlbGF5KGNvbmZpZy5zcGVlZCAqIDEuNyksXHJcbiAgICAgIHRhcCgoKSA9PiB0aGlzLnNldFN0YXRlKHsgYWN0aXZlOiBmYWxzZSB9KSksXHJcblxyXG4gICAgICAvLyBVc2UgYSB0aW55IGRlbGF5IGJlZm9yZSByZXNldHRpbmdcclxuICAgICAgZGVsYXkoY29uZmlnLnNwZWVkKSxcclxuICAgICAgLy8gRm9yY2UgdGhlIHByb2dyZXNzIHRvIHJlc2V0IGV2ZW4gaXQgZ290IGNhbmNlbGxlZFxyXG4gICAgICBmaW5hbGl6ZSgoKSA9PiB0aGlzLnNldFN0YXRlKHsgdmFsdWU6IDAgfSkpLFxyXG4gICAgICAvLyBDYW5jZWwgYW55IG9mIHRoZSBmaW5hbGl6aW5nIGRlbGF5cyBpZiB0aGUgcHJvZ3Jlc3MgaGFzIHN0YXJ0ZWQgYWdhaW5cclxuICAgICAgdGFrZVVudGlsKHRoaXMuX3N0YXJ0ZWQpXHJcbiAgICApO1xyXG4gIH1cclxufVxyXG4iXX0=