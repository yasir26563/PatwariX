{"version":3,"sources":["/Users/ahmedyasir/Downloads/PatwariX Revised/housekey-angular (1)/node_modules/ngx-progressbar/fesm2015/ngx-progressbar.js"],"names":[],"mappings":"AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AASA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAiXC,iHAKC;;;;;;;;;;;;;;;;kCAKgN;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CA4IjN,m7HAmCC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;oBAuBA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;CAsFD;;;;;;;;;0BAOC","file":"ngx-progressbar.js","sourcesContent":["import { Subject, Subscription, BehaviorSubject, combineLatest, timer, EMPTY, of } from 'rxjs';\nimport { filter, debounce, switchMap, tap, delay, finalize, takeUntil, map } from 'rxjs/operators';\nimport { InjectionToken, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass NgProgressRef {\r\n    /**\r\n     * @param {?} customConfig\r\n     * @param {?} _onDestroyCallback\r\n     */\r\n    constructor(customConfig, _onDestroyCallback) {\r\n        this._onDestroyCallback = _onDestroyCallback;\r\n        // Progress start source event (used to cancel finalizing delays)\r\n        this._started = new Subject();\r\n        // Progress start event: stream that emits only when it hasn't already started\r\n        this.started = this._started.pipe(filter((/**\r\n         * @return {?}\r\n         */\r\n        () => !this.isStarted)));\r\n        // Progress ended source event\r\n        this._completed = new Subject();\r\n        // Progress start event: stream that emits only when it has already started\r\n        this.completed = this._completed.pipe(filter((/**\r\n         * @return {?}\r\n         */\r\n        () => this.isStarted)));\r\n        // Stream that increments and updates the progress state\r\n        this._trickling = new Subject();\r\n        // Stream that combines \"_trickling\" and \"config\" streams\r\n        this._worker = Subscription.EMPTY;\r\n        this._state = new BehaviorSubject({ active: false, value: 0 });\r\n        this._config = new BehaviorSubject(customConfig);\r\n        this.state = this._state.asObservable();\r\n        this.config = this._state.asObservable();\r\n        this._worker = combineLatest(this._trickling, this._config).pipe(debounce((/**\r\n         * @param {?} __0\r\n         * @return {?}\r\n         */\r\n        ([start, config]) => timer(start ? config.debounceTime : 0))), switchMap((/**\r\n         * @param {?} __0\r\n         * @return {?}\r\n         */\r\n        ([start, config]) => start ? this.onTrickling(config) : this.onComplete(config)))).subscribe();\r\n    }\r\n    // Get current progress state\r\n    /**\r\n     * @private\r\n     * @return {?}\r\n     */\r\n    get currState() {\r\n        return this._state.value;\r\n    }\r\n    // Check if progress has started\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get isStarted() {\r\n        return this.currState.active;\r\n    }\r\n    /**\r\n     * Start the progress\r\n     * @return {?}\r\n     */\r\n    start() {\r\n        this._started.next();\r\n        this._trickling.next(true);\r\n    }\r\n    /**\r\n     * Complete the progress\r\n     * @return {?}\r\n     */\r\n    complete() {\r\n        this._trickling.next(false);\r\n    }\r\n    /**\r\n     * Increment the progress\r\n     * @param {?=} amount\r\n     * @return {?}\r\n     */\r\n    inc(amount) {\r\n        /** @type {?} */\r\n        const n = this.currState.value;\r\n        if (!this.isStarted) {\r\n            this.start();\r\n        }\r\n        else {\r\n            if (typeof amount !== 'number') {\r\n                amount = this._config.value.trickleFunc(n);\r\n            }\r\n            this.set(n + amount);\r\n        }\r\n    }\r\n    /**\r\n     * Set the progress\r\n     * @param {?} n\r\n     * @return {?}\r\n     */\r\n    set(n) {\r\n        this.setState({ value: this.clamp(n), active: true });\r\n    }\r\n    /**\r\n     * Set config\r\n     * @param {?} config\r\n     * @return {?}\r\n     */\r\n    setConfig(config) {\r\n        this._config.next(Object.assign({}, this._config.value, config));\r\n    }\r\n    /**\r\n     * Destroy progress reference\r\n     * @return {?}\r\n     */\r\n    destroy() {\r\n        this._worker.unsubscribe();\r\n        this._trickling.complete();\r\n        this._state.complete();\r\n        this._config.complete();\r\n        this._started.complete();\r\n        this._completed.complete();\r\n        this._onDestroyCallback();\r\n    }\r\n    /**\r\n     * Set progress state\r\n     * @private\r\n     * @param {?} state\r\n     * @return {?}\r\n     */\r\n    setState(state) {\r\n        this._state.next(Object.assign({}, this.currState, state));\r\n    }\r\n    /**\r\n     * Clamps a value to be between min and max\r\n     * @private\r\n     * @param {?} n\r\n     * @return {?}\r\n     */\r\n    clamp(n) {\r\n        return Math.max(this._config.value.min, Math.min(this._config.value.max, n));\r\n    }\r\n    /**\r\n     * Keeps incrementing the progress\r\n     * @private\r\n     * @param {?} config\r\n     * @return {?}\r\n     */\r\n    onTrickling(config) {\r\n        if (!this.isStarted) {\r\n            this.set(this._config.value.min);\r\n        }\r\n        return timer(0, config.trickleSpeed).pipe(tap((/**\r\n         * @return {?}\r\n         */\r\n        () => this.inc())));\r\n    }\r\n    /**\r\n     * Completes then resets the progress\r\n     * @private\r\n     * @param {?} config\r\n     * @return {?}\r\n     */\r\n    onComplete(config) {\r\n        this._completed.next();\r\n        return !this.isStarted ? EMPTY : of({}).pipe(\r\n        // Complete the progress\r\n        tap((/**\r\n         * @return {?}\r\n         */\r\n        () => this.setState({ value: 100 }))), \r\n        // Deactivate the progress after a tiny delay\r\n        delay(config.speed * 1.7), tap((/**\r\n         * @return {?}\r\n         */\r\n        () => this.setState({ active: false }))), \r\n        // Use a tiny delay before resetting\r\n        delay(config.speed), \r\n        // Force the progress to reset even it got cancelled\r\n        finalize((/**\r\n         * @return {?}\r\n         */\r\n        () => this.setState({ value: 0 }))), \r\n        // Cancel any of the finalizing delays if the progress has started again\r\n        takeUntil(this._started));\r\n    }\r\n}\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgressRef.prototype._state;\r\n    /** @type {?} */\r\n    NgProgressRef.prototype.state;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgressRef.prototype._config;\r\n    /** @type {?} */\r\n    NgProgressRef.prototype.config;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgressRef.prototype._started;\r\n    /** @type {?} */\r\n    NgProgressRef.prototype.started;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgressRef.prototype._completed;\r\n    /** @type {?} */\r\n    NgProgressRef.prototype.completed;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgressRef.prototype._trickling;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgressRef.prototype._worker;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgressRef.prototype._onDestroyCallback;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\n/**\r\n * @record\r\n */\r\nfunction NgProgressState() { }\r\nif (false) {\r\n    /** @type {?|undefined} */\r\n    NgProgressState.prototype.active;\r\n    /** @type {?|undefined} */\r\n    NgProgressState.prototype.value;\r\n}\r\n/**\r\n * @record\r\n */\r\nfunction NgProgressConfig() { }\r\nif (false) {\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.spinnerPosition;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.direction;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.ease;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.color;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.thick;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.fixed;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.meteor;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.spinner;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.max;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.min;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.speed;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.trickleSpeed;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.trickleFunc;\r\n    /** @type {?|undefined} */\r\n    NgProgressConfig.prototype.debounceTime;\r\n}\r\n/** @type {?} */\r\nconst NG_PROGRESS_CONFIG = new InjectionToken('ngProgressConfig');\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nconst ɵ0 = /**\r\n * @param {?} n\r\n * @return {?}\r\n */\r\n(n) => {\r\n    if (n >= 0 && n < 20)\r\n        return 10;\r\n    if (n >= 20 && n < 50)\r\n        return 4;\r\n    if (n >= 50 && n < 80)\r\n        return 2;\r\n    if (n >= 80 && n < 99)\r\n        return 0.5;\r\n    return 0;\r\n};\r\n/** @type {?} */\r\nconst defaultConfig = {\r\n    min: 8,\r\n    max: 100,\r\n    speed: 200,\r\n    debounceTime: 0,\r\n    trickleSpeed: 300,\r\n    fixed: true,\r\n    meteor: true,\r\n    thick: false,\r\n    spinner: true,\r\n    ease: 'linear',\r\n    color: '#1B95E0',\r\n    direction: 'ltr+',\r\n    spinnerPosition: 'right',\r\n    trickleFunc: (ɵ0)\r\n};\r\nclass NgProgress {\r\n    /**\r\n     * @param {?} config\r\n     */\r\n    constructor(config) {\r\n        // Store progress bar instances\r\n        this._instances = new Map();\r\n        this.config = config ? Object.assign({}, defaultConfig, config) : defaultConfig;\r\n    }\r\n    /**\r\n     * Get or Create progress bar by ID\r\n     * @param {?=} id\r\n     * @param {?=} config\r\n     * @return {?}\r\n     */\r\n    ref(id = 'root', config) {\r\n        if (this._instances.has(id)) {\r\n            // Get ProgressRef instance\r\n            /** @type {?} */\r\n            const progressRef = this._instances.get(id);\r\n            if (config) {\r\n                progressRef.setConfig(Object.assign({}, this.config, config));\r\n            }\r\n            return progressRef;\r\n        }\r\n        else {\r\n            // Create new ProgressRef instance\r\n            /** @type {?} */\r\n            const progressRef = new NgProgressRef(Object.assign({}, this.config, config), this.deleteInstance(id));\r\n            return this._instances.set(id, progressRef).get(id);\r\n        }\r\n    }\r\n    /**\r\n     * Destroy all progress bar instances\r\n     * @return {?}\r\n     */\r\n    destroyAll() {\r\n        this._instances.forEach((/**\r\n         * @param {?} ref\r\n         * @return {?}\r\n         */\r\n        (ref) => ref.destroy()));\r\n    }\r\n    /**\r\n     * A destroyer function for each progress bar instance\r\n     * @private\r\n     * @param {?} id\r\n     * @return {?}\r\n     */\r\n    deleteInstance(id) {\r\n        return (/**\r\n         * @return {?}\r\n         */\r\n        () => {\r\n            this._instances.delete(id);\r\n        });\r\n    }\r\n}\r\nNgProgress.decorators = [\r\n    { type: Injectable, args: [{\r\n                providedIn: 'root'\r\n            },] }\r\n];\r\n/** @nocollapse */\r\nNgProgress.ctorParameters = () => [\r\n    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_PROGRESS_CONFIG,] }] }\r\n];\r\n/** @nocollapse */ NgProgress.ngInjectableDef = ɵɵdefineInjectable({ factory: function NgProgress_Factory() { return new NgProgress(ɵɵinject(NG_PROGRESS_CONFIG, 8)); }, token: NgProgress, providedIn: \"root\" });\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgress.prototype._instances;\r\n    /** @type {?} */\r\n    NgProgress.prototype.config;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass NgProgressComponent {\r\n    /**\r\n     * @param {?} _ngProgress\r\n     */\r\n    constructor(_ngProgress) {\r\n        this._ngProgress = _ngProgress;\r\n        this._started = Subscription.EMPTY;\r\n        this._completed = Subscription.EMPTY;\r\n        /**\r\n         * Creates a new instance if id is not already exists\r\n         */\r\n        this.id = 'root';\r\n        /**\r\n         * Initializes inputs from the global config\r\n         */\r\n        this.min = this._ngProgress.config.min;\r\n        this.max = this._ngProgress.config.max;\r\n        this.ease = this._ngProgress.config.ease;\r\n        this.color = this._ngProgress.config.color;\r\n        this.speed = this._ngProgress.config.speed;\r\n        this.thick = this._ngProgress.config.thick;\r\n        this.fixed = this._ngProgress.config.fixed;\r\n        this.meteor = this._ngProgress.config.meteor;\r\n        this.spinner = this._ngProgress.config.spinner;\r\n        this.trickleSpeed = this._ngProgress.config.trickleSpeed;\r\n        this.debounceTime = this._ngProgress.config.debounceTime;\r\n        this.trickleFunc = this._ngProgress.config.trickleFunc;\r\n        this.spinnerPosition = this._ngProgress.config.spinnerPosition;\r\n        this.direction = this._ngProgress.config.direction;\r\n        this.started = new EventEmitter();\r\n        this.completed = new EventEmitter();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    get isStarted() {\r\n        return this.progressRef.isStarted;\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnChanges() {\r\n        if (this.progressRef instanceof NgProgressRef) {\r\n            // Update progress bar config when inputs change\r\n            this.progressRef.setConfig({\r\n                max: (this.max > 0 && this.max <= 100) ? this.max : 100,\r\n                min: (this.min < 100 && this.min >= 0) ? this.min : 0,\r\n                speed: this.speed,\r\n                trickleSpeed: this.trickleSpeed,\r\n                trickleFunc: this.trickleFunc,\r\n                debounceTime: this.debounceTime\r\n            });\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnInit() {\r\n        // Get progress bar service instance\r\n        this.progressRef = this._ngProgress.ref(this.id, {\r\n            max: this.max,\r\n            min: this.min,\r\n            speed: this.speed,\r\n            trickleSpeed: this.trickleSpeed,\r\n            debounceTime: this.debounceTime\r\n        });\r\n        // Subscribe to progress state\r\n        this.state$ = this.progressRef.state.pipe(map((/**\r\n         * @param {?} state\r\n         * @return {?}\r\n         */\r\n        (state) => ({\r\n            active: state.active,\r\n            transform: `translate3d(${state.value}%,0,0)`\r\n        }))));\r\n        // Subscribes to started and completed events on demand\r\n        if (this.started.observers.length) {\r\n            this._started = this.progressRef.started.subscribe((/**\r\n             * @return {?}\r\n             */\r\n            () => this.started.emit()));\r\n        }\r\n        if (this.completed.observers.length) {\r\n            this._completed = this.progressRef.completed.subscribe((/**\r\n             * @return {?}\r\n             */\r\n            () => this.completed.emit()));\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    ngOnDestroy() {\r\n        this._started.unsubscribe();\r\n        this._completed.unsubscribe();\r\n        if (this.progressRef instanceof NgProgressRef) {\r\n            this.progressRef.destroy();\r\n        }\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    start() {\r\n        this.progressRef.start();\r\n    }\r\n    /**\r\n     * @return {?}\r\n     */\r\n    complete() {\r\n        this.progressRef.complete();\r\n    }\r\n    /**\r\n     * @param {?=} n\r\n     * @return {?}\r\n     */\r\n    inc(n) {\r\n        this.progressRef.inc(n);\r\n    }\r\n    /**\r\n     * @param {?} n\r\n     * @return {?}\r\n     */\r\n    set(n) {\r\n        this.progressRef.set(n);\r\n    }\r\n}\r\nNgProgressComponent.decorators = [\r\n    { type: Component, args: [{\r\n                selector: 'ng-progress',\r\n                host: {\r\n                    'role': 'progressbar',\r\n                    '[attr.spinnerPosition]': 'spinnerPosition',\r\n                    '[attr.dir]': 'direction',\r\n                    '[attr.thick]': 'thick',\r\n                    '[attr.fixed]': 'fixed'\r\n                },\r\n                template: `\r\n    <ng-container *ngIf=\"state$ | async; let state\">\r\n      <div class=\"ng-progress-bar\"\r\n            [attr.active]=\"state.active\"\r\n            [style.transition]=\"'opacity ' + speed + 'ms ' + ease\">\r\n        <div class=\"ng-bar-placeholder\">\r\n          <div class=\"ng-bar\"\r\n                [style.transform]=\"state.transform\"\r\n                [style.backgroundColor]=\"color\"\r\n                [style.transition]=\"state.active ? 'all ' + speed + 'ms ' + ease : 'none'\">\r\n            <div *ngIf=\"meteor\" class=\"ng-meteor\" [style.boxShadow]=\"'0 0 10px '+ color + ', 0 0 5px ' + color\"></div>\r\n          </div>\r\n        </div>\r\n        <div *ngIf=\"spinner\" class=\"ng-spinner\">\r\n          <div class=\"ng-spinner-icon\"\r\n                [style.borderTopColor]=\"color\"\r\n                [style.borderLeftColor]=\"color\"></div>\r\n        </div>\r\n      </div>\r\n    </ng-container>\r\n  `,\r\n                changeDetection: ChangeDetectionStrategy.OnPush,\r\n                styles: [\":host{z-index:999999;pointer-events:none}:host[fixed=true] .ng-progress-bar,:host[fixed=true] .ng-spinner{position:fixed}:host[fixed=true] .ng-spinner{top:15px}:host[fixed=true][spinnerPosition=left] .ng-spinner{left:15px}:host[fixed=true][spinnerPosition=right] .ng-spinner{right:15px}:host[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}:host[thick=true] .ng-bar-placeholder{height:3px!important}:host[dir=\\\"ltr+\\\"] .ng-meteor,:host[dir=ltr-] .ng-meteor{-webkit-transform:rotate(3deg);transform:rotate(3deg)}:host[dir=\\\"ltr+\\\"][thick=true] .ng-meteor,:host[dir=ltr-][thick=true] .ng-meteor{-webkit-transform:rotate(4deg);transform:rotate(4deg)}:host[dir=\\\"ltr+\\\"] .ng-bar,:host[dir=\\\"rtl+\\\"] .ng-bar{margin-left:-100%}:host[dir=\\\"ltr+\\\"] .ng-meteor,:host[dir=\\\"rtl+\\\"] .ng-meteor{right:0}:host[dir=\\\"ltr+\\\"] .ng-meteor,:host[dir=rtl-] .ng-meteor{top:-3px}:host[dir=\\\"ltr+\\\"][thick=true] .ng-meteor,:host[dir=rtl-][thick=true] .ng-meteor{top:-4px}:host[dir=\\\"rtl+\\\"] .ng-meteor,:host[dir=ltr-] .ng-meteor{bottom:-3px}:host[dir=\\\"rtl+\\\"][thick=true] .ng-meteor,:host[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}:host[dir=\\\"rtl+\\\"] .ng-bar-placeholder,:host[dir=ltr-] .ng-bar-placeholder{-webkit-transform:rotate(180deg);transform:rotate(180deg)}:host[dir=\\\"rtl+\\\"] .ng-spinner-icon,:host[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}:host[dir=\\\"rtl+\\\"] .ng-meteor,:host[dir=rtl-] .ng-meteor{-webkit-transform:rotate(-3deg);transform:rotate(-3deg)}:host[dir=\\\"rtl+\\\"][thick=true] .ng-meteor,:host[dir=rtl-][thick=true] .ng-meteor{-webkit-transform:rotate(-4deg);transform:rotate(-4deg)}:host[spinnerPosition=left] .ng-spinner{left:10px}:host[spinnerPosition=right] .ng-spinner{right:10px}.ng-progress-bar{position:relative;z-index:999999;top:0;left:0;width:100%;zoom:1;opacity:0}.ng-progress-bar[active=true]{opacity:1;-webkit-transition:none;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;-webkit-transform:translate(-100%,0,0);transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:250ms linear infinite spinner-animation;animation:250ms linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}\"]\r\n            }] }\r\n];\r\n/** @nocollapse */\r\nNgProgressComponent.ctorParameters = () => [\r\n    { type: NgProgress }\r\n];\r\nNgProgressComponent.propDecorators = {\r\n    id: [{ type: Input }],\r\n    min: [{ type: Input }],\r\n    max: [{ type: Input }],\r\n    ease: [{ type: Input }],\r\n    color: [{ type: Input }],\r\n    speed: [{ type: Input }],\r\n    thick: [{ type: Input }],\r\n    fixed: [{ type: Input }],\r\n    meteor: [{ type: Input }],\r\n    spinner: [{ type: Input }],\r\n    trickleSpeed: [{ type: Input }],\r\n    debounceTime: [{ type: Input }],\r\n    trickleFunc: [{ type: Input }],\r\n    spinnerPosition: [{ type: Input }],\r\n    direction: [{ type: Input }],\r\n    started: [{ type: Output }],\r\n    completed: [{ type: Output }]\r\n};\r\nif (false) {\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgressComponent.prototype._started;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgressComponent.prototype._completed;\r\n    /**\r\n     * Progress bar worker\r\n     * @type {?}\r\n     */\r\n    NgProgressComponent.prototype.progressRef;\r\n    /**\r\n     * Stream that emits progress state\r\n     * @type {?}\r\n     */\r\n    NgProgressComponent.prototype.state$;\r\n    /**\r\n     * Creates a new instance if id is not already exists\r\n     * @type {?}\r\n     */\r\n    NgProgressComponent.prototype.id;\r\n    /**\r\n     * Initializes inputs from the global config\r\n     * @type {?}\r\n     */\r\n    NgProgressComponent.prototype.min;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.max;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.ease;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.color;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.speed;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.thick;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.fixed;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.meteor;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.spinner;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.trickleSpeed;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.debounceTime;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.trickleFunc;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.spinnerPosition;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.direction;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.started;\r\n    /** @type {?} */\r\n    NgProgressComponent.prototype.completed;\r\n    /**\r\n     * @type {?}\r\n     * @private\r\n     */\r\n    NgProgressComponent.prototype._ngProgress;\r\n}\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\r\nclass NgProgressModule {\r\n    /**\r\n     * @param {?} config\r\n     * @return {?}\r\n     */\r\n    static withConfig(config) {\r\n        return {\r\n            ngModule: NgProgressModule,\r\n            providers: [\r\n                { provide: NG_PROGRESS_CONFIG, useValue: config }\r\n            ]\r\n        };\r\n    }\r\n}\r\nNgProgressModule.decorators = [\r\n    { type: NgModule, args: [{\r\n                declarations: [NgProgressComponent],\r\n                exports: [NgProgressComponent],\r\n                imports: [CommonModule]\r\n            },] }\r\n];\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\n/**\r\n * @fileoverview added by tsickle\r\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\r\n */\n\nexport { NG_PROGRESS_CONFIG, NgProgress, NgProgressComponent, NgProgressModule, NgProgressRef };\n"]}