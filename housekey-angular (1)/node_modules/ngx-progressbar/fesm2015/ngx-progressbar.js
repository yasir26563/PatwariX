import { Subject, Subscription, BehaviorSubject, combineLatest, timer, EMPTY, of } from 'rxjs';
import { filter, debounce, switchMap, tap, delay, finalize, takeUntil, map } from 'rxjs/operators';
import { InjectionToken, Injectable, Optional, Inject, ɵɵdefineInjectable, ɵɵinject, EventEmitter, Component, ChangeDetectionStrategy, Input, Output, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgProgressRef {
    /**
     * @param {?} customConfig
     * @param {?} _onDestroyCallback
     */
    constructor(customConfig, _onDestroyCallback) {
        this._onDestroyCallback = _onDestroyCallback;
        // Progress start source event (used to cancel finalizing delays)
        this._started = new Subject();
        // Progress start event: stream that emits only when it hasn't already started
        this.started = this._started.pipe(filter((/**
         * @return {?}
         */
        () => !this.isStarted)));
        // Progress ended source event
        this._completed = new Subject();
        // Progress start event: stream that emits only when it has already started
        this.completed = this._completed.pipe(filter((/**
         * @return {?}
         */
        () => this.isStarted)));
        // Stream that increments and updates the progress state
        this._trickling = new Subject();
        // Stream that combines "_trickling" and "config" streams
        this._worker = Subscription.EMPTY;
        this._state = new BehaviorSubject({ active: false, value: 0 });
        this._config = new BehaviorSubject(customConfig);
        this.state = this._state.asObservable();
        this.config = this._state.asObservable();
        this._worker = combineLatest(this._trickling, this._config).pipe(debounce((/**
         * @param {?} __0
         * @return {?}
         */
        ([start, config]) => timer(start ? config.debounceTime : 0))), switchMap((/**
         * @param {?} __0
         * @return {?}
         */
        ([start, config]) => start ? this.onTrickling(config) : this.onComplete(config)))).subscribe();
    }
    // Get current progress state
    /**
     * @private
     * @return {?}
     */
    get currState() {
        return this._state.value;
    }
    // Check if progress has started
    /**
     * @return {?}
     */
    get isStarted() {
        return this.currState.active;
    }
    /**
     * Start the progress
     * @return {?}
     */
    start() {
        this._started.next();
        this._trickling.next(true);
    }
    /**
     * Complete the progress
     * @return {?}
     */
    complete() {
        this._trickling.next(false);
    }
    /**
     * Increment the progress
     * @param {?=} amount
     * @return {?}
     */
    inc(amount) {
        /** @type {?} */
        const n = this.currState.value;
        if (!this.isStarted) {
            this.start();
        }
        else {
            if (typeof amount !== 'number') {
                amount = this._config.value.trickleFunc(n);
            }
            this.set(n + amount);
        }
    }
    /**
     * Set the progress
     * @param {?} n
     * @return {?}
     */
    set(n) {
        this.setState({ value: this.clamp(n), active: true });
    }
    /**
     * Set config
     * @param {?} config
     * @return {?}
     */
    setConfig(config) {
        this._config.next(Object.assign({}, this._config.value, config));
    }
    /**
     * Destroy progress reference
     * @return {?}
     */
    destroy() {
        this._worker.unsubscribe();
        this._trickling.complete();
        this._state.complete();
        this._config.complete();
        this._started.complete();
        this._completed.complete();
        this._onDestroyCallback();
    }
    /**
     * Set progress state
     * @private
     * @param {?} state
     * @return {?}
     */
    setState(state) {
        this._state.next(Object.assign({}, this.currState, state));
    }
    /**
     * Clamps a value to be between min and max
     * @private
     * @param {?} n
     * @return {?}
     */
    clamp(n) {
        return Math.max(this._config.value.min, Math.min(this._config.value.max, n));
    }
    /**
     * Keeps incrementing the progress
     * @private
     * @param {?} config
     * @return {?}
     */
    onTrickling(config) {
        if (!this.isStarted) {
            this.set(this._config.value.min);
        }
        return timer(0, config.trickleSpeed).pipe(tap((/**
         * @return {?}
         */
        () => this.inc())));
    }
    /**
     * Completes then resets the progress
     * @private
     * @param {?} config
     * @return {?}
     */
    onComplete(config) {
        this._completed.next();
        return !this.isStarted ? EMPTY : of({}).pipe(
        // Complete the progress
        tap((/**
         * @return {?}
         */
        () => this.setState({ value: 100 }))), 
        // Deactivate the progress after a tiny delay
        delay(config.speed * 1.7), tap((/**
         * @return {?}
         */
        () => this.setState({ active: false }))), 
        // Use a tiny delay before resetting
        delay(config.speed), 
        // Force the progress to reset even it got cancelled
        finalize((/**
         * @return {?}
         */
        () => this.setState({ value: 0 }))), 
        // Cancel any of the finalizing delays if the progress has started again
        takeUntil(this._started));
    }
}
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._state;
    /** @type {?} */
    NgProgressRef.prototype.state;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._config;
    /** @type {?} */
    NgProgressRef.prototype.config;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._started;
    /** @type {?} */
    NgProgressRef.prototype.started;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._completed;
    /** @type {?} */
    NgProgressRef.prototype.completed;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._trickling;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._worker;
    /**
     * @type {?}
     * @private
     */
    NgProgressRef.prototype._onDestroyCallback;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
/**
 * @record
 */
function NgProgressState() { }
if (false) {
    /** @type {?|undefined} */
    NgProgressState.prototype.active;
    /** @type {?|undefined} */
    NgProgressState.prototype.value;
}
/**
 * @record
 */
function NgProgressConfig() { }
if (false) {
    /** @type {?|undefined} */
    NgProgressConfig.prototype.spinnerPosition;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.direction;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.ease;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.color;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.thick;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.fixed;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.meteor;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.spinner;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.max;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.min;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.speed;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.trickleSpeed;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.trickleFunc;
    /** @type {?|undefined} */
    NgProgressConfig.prototype.debounceTime;
}
/** @type {?} */
const NG_PROGRESS_CONFIG = new InjectionToken('ngProgressConfig');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
const ɵ0 = /**
 * @param {?} n
 * @return {?}
 */
(n) => {
    if (n >= 0 && n < 20)
        return 10;
    if (n >= 20 && n < 50)
        return 4;
    if (n >= 50 && n < 80)
        return 2;
    if (n >= 80 && n < 99)
        return 0.5;
    return 0;
};
/** @type {?} */
const defaultConfig = {
    min: 8,
    max: 100,
    speed: 200,
    debounceTime: 0,
    trickleSpeed: 300,
    fixed: true,
    meteor: true,
    thick: false,
    spinner: true,
    ease: 'linear',
    color: '#1B95E0',
    direction: 'ltr+',
    spinnerPosition: 'right',
    trickleFunc: (ɵ0)
};
class NgProgress {
    /**
     * @param {?} config
     */
    constructor(config) {
        // Store progress bar instances
        this._instances = new Map();
        this.config = config ? Object.assign({}, defaultConfig, config) : defaultConfig;
    }
    /**
     * Get or Create progress bar by ID
     * @param {?=} id
     * @param {?=} config
     * @return {?}
     */
    ref(id = 'root', config) {
        if (this._instances.has(id)) {
            // Get ProgressRef instance
            /** @type {?} */
            const progressRef = this._instances.get(id);
            if (config) {
                progressRef.setConfig(Object.assign({}, this.config, config));
            }
            return progressRef;
        }
        else {
            // Create new ProgressRef instance
            /** @type {?} */
            const progressRef = new NgProgressRef(Object.assign({}, this.config, config), this.deleteInstance(id));
            return this._instances.set(id, progressRef).get(id);
        }
    }
    /**
     * Destroy all progress bar instances
     * @return {?}
     */
    destroyAll() {
        this._instances.forEach((/**
         * @param {?} ref
         * @return {?}
         */
        (ref) => ref.destroy()));
    }
    /**
     * A destroyer function for each progress bar instance
     * @private
     * @param {?} id
     * @return {?}
     */
    deleteInstance(id) {
        return (/**
         * @return {?}
         */
        () => {
            this._instances.delete(id);
        });
    }
}
NgProgress.decorators = [
    { type: Injectable, args: [{
                providedIn: 'root'
            },] }
];
/** @nocollapse */
NgProgress.ctorParameters = () => [
    { type: undefined, decorators: [{ type: Optional }, { type: Inject, args: [NG_PROGRESS_CONFIG,] }] }
];
/** @nocollapse */ NgProgress.ngInjectableDef = ɵɵdefineInjectable({ factory: function NgProgress_Factory() { return new NgProgress(ɵɵinject(NG_PROGRESS_CONFIG, 8)); }, token: NgProgress, providedIn: "root" });
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgProgress.prototype._instances;
    /** @type {?} */
    NgProgress.prototype.config;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgProgressComponent {
    /**
     * @param {?} _ngProgress
     */
    constructor(_ngProgress) {
        this._ngProgress = _ngProgress;
        this._started = Subscription.EMPTY;
        this._completed = Subscription.EMPTY;
        /**
         * Creates a new instance if id is not already exists
         */
        this.id = 'root';
        /**
         * Initializes inputs from the global config
         */
        this.min = this._ngProgress.config.min;
        this.max = this._ngProgress.config.max;
        this.ease = this._ngProgress.config.ease;
        this.color = this._ngProgress.config.color;
        this.speed = this._ngProgress.config.speed;
        this.thick = this._ngProgress.config.thick;
        this.fixed = this._ngProgress.config.fixed;
        this.meteor = this._ngProgress.config.meteor;
        this.spinner = this._ngProgress.config.spinner;
        this.trickleSpeed = this._ngProgress.config.trickleSpeed;
        this.debounceTime = this._ngProgress.config.debounceTime;
        this.trickleFunc = this._ngProgress.config.trickleFunc;
        this.spinnerPosition = this._ngProgress.config.spinnerPosition;
        this.direction = this._ngProgress.config.direction;
        this.started = new EventEmitter();
        this.completed = new EventEmitter();
    }
    /**
     * @return {?}
     */
    get isStarted() {
        return this.progressRef.isStarted;
    }
    /**
     * @return {?}
     */
    ngOnChanges() {
        if (this.progressRef instanceof NgProgressRef) {
            // Update progress bar config when inputs change
            this.progressRef.setConfig({
                max: (this.max > 0 && this.max <= 100) ? this.max : 100,
                min: (this.min < 100 && this.min >= 0) ? this.min : 0,
                speed: this.speed,
                trickleSpeed: this.trickleSpeed,
                trickleFunc: this.trickleFunc,
                debounceTime: this.debounceTime
            });
        }
    }
    /**
     * @return {?}
     */
    ngOnInit() {
        // Get progress bar service instance
        this.progressRef = this._ngProgress.ref(this.id, {
            max: this.max,
            min: this.min,
            speed: this.speed,
            trickleSpeed: this.trickleSpeed,
            debounceTime: this.debounceTime
        });
        // Subscribe to progress state
        this.state$ = this.progressRef.state.pipe(map((/**
         * @param {?} state
         * @return {?}
         */
        (state) => ({
            active: state.active,
            transform: `translate3d(${state.value}%,0,0)`
        }))));
        // Subscribes to started and completed events on demand
        if (this.started.observers.length) {
            this._started = this.progressRef.started.subscribe((/**
             * @return {?}
             */
            () => this.started.emit()));
        }
        if (this.completed.observers.length) {
            this._completed = this.progressRef.completed.subscribe((/**
             * @return {?}
             */
            () => this.completed.emit()));
        }
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._started.unsubscribe();
        this._completed.unsubscribe();
        if (this.progressRef instanceof NgProgressRef) {
            this.progressRef.destroy();
        }
    }
    /**
     * @return {?}
     */
    start() {
        this.progressRef.start();
    }
    /**
     * @return {?}
     */
    complete() {
        this.progressRef.complete();
    }
    /**
     * @param {?=} n
     * @return {?}
     */
    inc(n) {
        this.progressRef.inc(n);
    }
    /**
     * @param {?} n
     * @return {?}
     */
    set(n) {
        this.progressRef.set(n);
    }
}
NgProgressComponent.decorators = [
    { type: Component, args: [{
                selector: 'ng-progress',
                host: {
                    'role': 'progressbar',
                    '[attr.spinnerPosition]': 'spinnerPosition',
                    '[attr.dir]': 'direction',
                    '[attr.thick]': 'thick',
                    '[attr.fixed]': 'fixed'
                },
                template: `
    <ng-container *ngIf="state$ | async; let state">
      <div class="ng-progress-bar"
            [attr.active]="state.active"
            [style.transition]="'opacity ' + speed + 'ms ' + ease">
        <div class="ng-bar-placeholder">
          <div class="ng-bar"
                [style.transform]="state.transform"
                [style.backgroundColor]="color"
                [style.transition]="state.active ? 'all ' + speed + 'ms ' + ease : 'none'">
            <div *ngIf="meteor" class="ng-meteor" [style.boxShadow]="'0 0 10px '+ color + ', 0 0 5px ' + color"></div>
          </div>
        </div>
        <div *ngIf="spinner" class="ng-spinner">
          <div class="ng-spinner-icon"
                [style.borderTopColor]="color"
                [style.borderLeftColor]="color"></div>
        </div>
      </div>
    </ng-container>
  `,
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{z-index:999999;pointer-events:none}:host[fixed=true] .ng-progress-bar,:host[fixed=true] .ng-spinner{position:fixed}:host[fixed=true] .ng-spinner{top:15px}:host[fixed=true][spinnerPosition=left] .ng-spinner{left:15px}:host[fixed=true][spinnerPosition=right] .ng-spinner{right:15px}:host[thick=true] .ng-spinner-icon{width:24px;height:24px;border-width:3px}:host[thick=true] .ng-bar-placeholder{height:3px!important}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=ltr-] .ng-meteor{-webkit-transform:rotate(3deg);transform:rotate(3deg)}:host[dir=\"ltr+\"][thick=true] .ng-meteor,:host[dir=ltr-][thick=true] .ng-meteor{-webkit-transform:rotate(4deg);transform:rotate(4deg)}:host[dir=\"ltr+\"] .ng-bar,:host[dir=\"rtl+\"] .ng-bar{margin-left:-100%}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=\"rtl+\"] .ng-meteor{right:0}:host[dir=\"ltr+\"] .ng-meteor,:host[dir=rtl-] .ng-meteor{top:-3px}:host[dir=\"ltr+\"][thick=true] .ng-meteor,:host[dir=rtl-][thick=true] .ng-meteor{top:-4px}:host[dir=\"rtl+\"] .ng-meteor,:host[dir=ltr-] .ng-meteor{bottom:-3px}:host[dir=\"rtl+\"][thick=true] .ng-meteor,:host[dir=ltr-][thick=true] .ng-meteor{bottom:-4px}:host[dir=\"rtl+\"] .ng-bar-placeholder,:host[dir=ltr-] .ng-bar-placeholder{-webkit-transform:rotate(180deg);transform:rotate(180deg)}:host[dir=\"rtl+\"] .ng-spinner-icon,:host[dir=ltr-] .ng-spinner-icon{animation-direction:reverse}:host[dir=\"rtl+\"] .ng-meteor,:host[dir=rtl-] .ng-meteor{-webkit-transform:rotate(-3deg);transform:rotate(-3deg)}:host[dir=\"rtl+\"][thick=true] .ng-meteor,:host[dir=rtl-][thick=true] .ng-meteor{-webkit-transform:rotate(-4deg);transform:rotate(-4deg)}:host[spinnerPosition=left] .ng-spinner{left:10px}:host[spinnerPosition=right] .ng-spinner{right:10px}.ng-progress-bar{position:relative;z-index:999999;top:0;left:0;width:100%;zoom:1;opacity:0}.ng-progress-bar[active=true]{opacity:1;-webkit-transition:none;transition:none}.ng-bar-placeholder{position:absolute;height:2px;width:100%}.ng-bar{width:100%;height:100%;-webkit-transform:translate(-100%,0,0);transform:translate(-100%,0,0)}.ng-meteor{display:block;position:absolute;width:100px;height:100%;opacity:1}.ng-spinner{position:absolute;display:block;z-index:1031;top:10px}.ng-spinner-icon{width:18px;height:18px;box-sizing:border-box;-webkit-animation:250ms linear infinite spinner-animation;animation:250ms linear infinite spinner-animation;border:2px solid transparent;border-radius:50%}@-webkit-keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}@keyframes spinner-animation{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}"]
            }] }
];
/** @nocollapse */
NgProgressComponent.ctorParameters = () => [
    { type: NgProgress }
];
NgProgressComponent.propDecorators = {
    id: [{ type: Input }],
    min: [{ type: Input }],
    max: [{ type: Input }],
    ease: [{ type: Input }],
    color: [{ type: Input }],
    speed: [{ type: Input }],
    thick: [{ type: Input }],
    fixed: [{ type: Input }],
    meteor: [{ type: Input }],
    spinner: [{ type: Input }],
    trickleSpeed: [{ type: Input }],
    debounceTime: [{ type: Input }],
    trickleFunc: [{ type: Input }],
    spinnerPosition: [{ type: Input }],
    direction: [{ type: Input }],
    started: [{ type: Output }],
    completed: [{ type: Output }]
};
if (false) {
    /**
     * @type {?}
     * @private
     */
    NgProgressComponent.prototype._started;
    /**
     * @type {?}
     * @private
     */
    NgProgressComponent.prototype._completed;
    /**
     * Progress bar worker
     * @type {?}
     */
    NgProgressComponent.prototype.progressRef;
    /**
     * Stream that emits progress state
     * @type {?}
     */
    NgProgressComponent.prototype.state$;
    /**
     * Creates a new instance if id is not already exists
     * @type {?}
     */
    NgProgressComponent.prototype.id;
    /**
     * Initializes inputs from the global config
     * @type {?}
     */
    NgProgressComponent.prototype.min;
    /** @type {?} */
    NgProgressComponent.prototype.max;
    /** @type {?} */
    NgProgressComponent.prototype.ease;
    /** @type {?} */
    NgProgressComponent.prototype.color;
    /** @type {?} */
    NgProgressComponent.prototype.speed;
    /** @type {?} */
    NgProgressComponent.prototype.thick;
    /** @type {?} */
    NgProgressComponent.prototype.fixed;
    /** @type {?} */
    NgProgressComponent.prototype.meteor;
    /** @type {?} */
    NgProgressComponent.prototype.spinner;
    /** @type {?} */
    NgProgressComponent.prototype.trickleSpeed;
    /** @type {?} */
    NgProgressComponent.prototype.debounceTime;
    /** @type {?} */
    NgProgressComponent.prototype.trickleFunc;
    /** @type {?} */
    NgProgressComponent.prototype.spinnerPosition;
    /** @type {?} */
    NgProgressComponent.prototype.direction;
    /** @type {?} */
    NgProgressComponent.prototype.started;
    /** @type {?} */
    NgProgressComponent.prototype.completed;
    /**
     * @type {?}
     * @private
     */
    NgProgressComponent.prototype._ngProgress;
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
class NgProgressModule {
    /**
     * @param {?} config
     * @return {?}
     */
    static withConfig(config) {
        return {
            ngModule: NgProgressModule,
            providers: [
                { provide: NG_PROGRESS_CONFIG, useValue: config }
            ]
        };
    }
}
NgProgressModule.decorators = [
    { type: NgModule, args: [{
                declarations: [NgProgressComponent],
                exports: [NgProgressComponent],
                imports: [CommonModule]
            },] }
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */

export { NG_PROGRESS_CONFIG, NgProgress, NgProgressComponent, NgProgressModule, NgProgressRef };
//# sourceMappingURL=ngx-progressbar.js.map
