import { __decorate, __metadata, __param } from 'tslib';
import { CommonModule } from '@angular/common';
import { Injectable, EventEmitter, ViewChild, ElementRef, Input, Output, Component, Renderer2, Directive, Host, ChangeDetectionStrategy, Optional, Attribute, ChangeDetectorRef, Pipe, HostListener, NgModule } from '@angular/core';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatSlider, MAT_SLIDER_VALUE_ACCESSOR, MatSliderModule } from '@angular/material/slider';
import { FocusMonitor } from '@angular/cdk/a11y';
import { Directionality } from '@angular/cdk/bidi';

import * as ɵngcc0 from '@angular/core';
import * as ɵngcc1 from '@angular/common';
import * as ɵngcc2 from '@angular/cdk/a11y';
import * as ɵngcc3 from '@angular/cdk/bidi';
import * as ɵngcc4 from '@angular/material/button';
import * as ɵngcc5 from '@angular/material/icon';
import * as ɵngcc6 from '@angular/material/slider';

const _c0 = ["player"];
const _c1 = ["video"];
function MatVideoComponent_div_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 7);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r240 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵproperty("ngClass", ctx_r240.getOverlayClass("visible", "hidden"));
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r240.title, " ");
} }
function MatVideoComponent_div_8_mat_frame_by_frame_control_6_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "mat-frame-by-frame-control", 21);
} if (rf & 2) {
    const ctx_r243 = ɵngcc0.ɵɵnextContext(2);
    const _r241 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("video", _r241)("fps", ctx_r243.fps);
} }
function MatVideoComponent_div_8_mat_quality_control_10_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "mat-quality-control", 16);
} if (rf & 2) {
    ɵngcc0.ɵɵnextContext(2);
    const _r241 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("video", _r241);
} }
function MatVideoComponent_div_8_mat_download_button_11_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "mat-download-button", 22);
} if (rf & 2) {
    const ctx_r245 = ɵngcc0.ɵɵnextContext(2);
    const _r241 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("title", ctx_r245.title)("video", _r241);
} }
function MatVideoComponent_div_8_mat_fullscreen_button_12_Template(rf, ctx) { if (rf & 1) {
    const _r248 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "mat-fullscreen-button", 23);
    ɵngcc0.ɵɵlistener("fullscreenChanged", function MatVideoComponent_div_8_mat_fullscreen_button_12_Template_mat_fullscreen_button_fullscreenChanged_0_listener($event) { ɵngcc0.ɵɵrestoreView(_r248); const ctx_r247 = ɵngcc0.ɵɵnextContext(2); return ctx_r247.isFullscreen = $event; });
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r246 = ɵngcc0.ɵɵnextContext(2);
    const _r239 = ɵngcc0.ɵɵreference(1);
    ɵngcc0.ɵɵproperty("player", _r239)("keyboard", ctx_r246.keyboard);
} }
function MatVideoComponent_div_8_Template(rf, ctx) { if (rf & 1) {
    const _r250 = ɵngcc0.ɵɵgetCurrentView();
    ɵngcc0.ɵɵelementStart(0, "div", 8);
    ɵngcc0.ɵɵelementStart(1, "div", 9);
    ɵngcc0.ɵɵelement(2, "mat-seek-progress-control", 10);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(3, "div", 11);
    ɵngcc0.ɵɵelementStart(4, "div", 12);
    ɵngcc0.ɵɵelementStart(5, "mat-play-button", 13);
    ɵngcc0.ɵɵlistener("playChanged", function MatVideoComponent_div_8_Template_mat_play_button_playChanged_5_listener($event) { ɵngcc0.ɵɵrestoreView(_r250); const ctx_r249 = ɵngcc0.ɵɵnextContext(); return ctx_r249.playing = $event; });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵtemplate(6, MatVideoComponent_div_8_mat_frame_by_frame_control_6_Template, 1, 2, "mat-frame-by-frame-control", 14);
    ɵngcc0.ɵɵelementStart(7, "mat-volume-control", 15);
    ɵngcc0.ɵɵlistener("mutedChanged", function MatVideoComponent_div_8_Template_mat_volume_control_mutedChanged_7_listener($event) { ɵngcc0.ɵɵrestoreView(_r250); const ctx_r251 = ɵngcc0.ɵɵnextContext(); ctx_r251.muted = $event; return ctx_r251.mutedChange.emit(ctx_r251.muted); });
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelement(8, "mat-time-control", 16);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementStart(9, "div", 17);
    ɵngcc0.ɵɵtemplate(10, MatVideoComponent_div_8_mat_quality_control_10_Template, 1, 1, "mat-quality-control", 18);
    ɵngcc0.ɵɵtemplate(11, MatVideoComponent_div_8_mat_download_button_11_Template, 1, 2, "mat-download-button", 19);
    ɵngcc0.ɵɵtemplate(12, MatVideoComponent_div_8_mat_fullscreen_button_12_Template, 1, 2, "mat-fullscreen-button", 20);
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r242 = ɵngcc0.ɵɵnextContext();
    const _r241 = ɵngcc0.ɵɵreference(4);
    ɵngcc0.ɵɵproperty("ngClass", ctx_r242.getOverlayClass("visible", "hidden"));
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("color", ctx_r242.color)("video", _r241);
    ɵngcc0.ɵɵadvance(3);
    ɵngcc0.ɵɵproperty("video", _r241)("keyboard", ctx_r242.keyboard);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r242.showFrameByFrame);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("muted", ctx_r242.muted)("color", ctx_r242.color)("video", _r241)("keyboard", ctx_r242.keyboard);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("video", _r241);
    ɵngcc0.ɵɵadvance(2);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r242.quality);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r242.download);
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵproperty("ngIf", ctx_r242.fullscreen);
} }
const _c2 = [[["source"]], [["track"]]];
const _c3 = ["source", "track"];
function MatFullscreenButtonComponent_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "fullscreen");
    ɵngcc0.ɵɵelementEnd();
} }
function MatFullscreenButtonComponent_mat_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "fullscreen_exit");
    ɵngcc0.ɵɵelementEnd();
} }
function MatPlayButtonComponent_mat_icon_1_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "play_arrow");
    ɵngcc0.ɵɵelementEnd();
} }
function MatPlayButtonComponent_mat_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "pause");
    ɵngcc0.ɵɵelementEnd();
} }
function MatQualityControlComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "div", 1);
    ɵngcc0.ɵɵtext(1);
    ɵngcc0.ɵɵelementEnd();
} if (rf & 2) {
    const ctx_r257 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵadvance(1);
    ɵngcc0.ɵɵtextInterpolate1(" ", ctx_r257.video.videoHeight, "p\n");
} }
function MatVideoSpinnerComponent_div_0_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelement(0, "div");
} if (rf & 2) {
    const ctx_r258 = ɵngcc0.ɵɵnextContext();
    ɵngcc0.ɵɵclassMap(ctx_r258.spinner);
} }
function MatVolumeControlComponent_mat_icon_2_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_off");
    ɵngcc0.ɵɵelementEnd();
} }
function MatVolumeControlComponent_mat_icon_3_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_mute");
    ɵngcc0.ɵɵelementEnd();
} }
function MatVolumeControlComponent_mat_icon_4_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_down");
    ɵngcc0.ɵɵelementEnd();
} }
function MatVolumeControlComponent_mat_icon_5_Template(rf, ctx) { if (rf & 1) {
    ɵngcc0.ɵɵelementStart(0, "mat-icon");
    ɵngcc0.ɵɵtext(1, "volume_up");
    ɵngcc0.ɵɵelementEnd();
} }
let EventService = class EventService {
    constructor() { }
    addEvents(renderer, events) {
        for (const event of events)
            event.dispose = renderer.listen(event.element, event.name, newEvent => event.callback(newEvent));
    }
    removeEvents(events) {
        for (const event of events)
            if (event.dispose)
                event.dispose();
    }
};
EventService.ɵfac = function EventService_Factory(t) { return new (t || EventService)(); };
EventService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: EventService, factory: EventService.ɵfac });
EventService = __decorate([ __metadata("design:paramtypes", [])
], EventService);

let MatVideoComponent = class MatVideoComponent {
    constructor(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.src = null;
        this.title = null;
        this.autoplay = false;
        this.preload = true;
        this.loop = false;
        this.quality = true;
        this.fullscreen = true;
        this.showFrameByFrame = false;
        this.fps = 29.97;
        this.download = false;
        this.color = 'primary';
        this.spinner = 'spin';
        this.poster = null;
        this.keyboard = true;
        this.overlay = null;
        this.muted = false;
        this.mutedChange = new EventEmitter();
        this.timeChange = new EventEmitter();
        this.playing = false;
        this.isFullscreen = false;
        this.videoLoaded = false;
        this.isMouseMoving = false;
        this.isMouseMovingTimeout = 2000;
    }
    get time() {
        return this.getVideoTag().currentTime;
    }
    set time(val) {
        const video = this.getVideoTag();
        if (video && val) {
            if (val > video.duration) {
                val = video.duration;
            }
            if (val < 0) {
                val = 0;
            }
            if (val !== video.currentTime) {
                video.currentTime = val;
            }
            if (this.lastTime !== video.currentTime) {
                setTimeout(() => this.timeChange.emit(video.currentTime), 0);
                this.lastTime = video.currentTime;
            }
        }
    }
    ngAfterViewInit() {
        this.events = [
            { element: this.video.nativeElement, name: 'loadstart', callback: event => this.videoLoaded = false, dispose: null },
            { element: this.video.nativeElement, name: 'loadedmetadata', callback: event => this.evLoadedMetadata(event), dispose: null },
            { element: this.video.nativeElement, name: 'error', callback: event => console.error('Unhandled Video Error', event), dispose: null },
            { element: this.video.nativeElement, name: 'contextmenu', callback: event => event.preventDefault(), dispose: null },
            { element: this.video.nativeElement, name: 'timeupdate', callback: event => this.evTimeUpdate(event), dispose: null },
            { element: this.player.nativeElement, name: 'mousemove', callback: event => this.evMouseMove(event), dispose: null }
        ];
        this.video.nativeElement.onloadeddata = () => this.videoLoaded = true;
        this.evt.addEvents(this.renderer, this.events);
    }
    ngOnDestroy() {
        this.video.nativeElement.onloadeddata = null;
        this.evt.removeEvents(this.events);
    }
    load() {
        if (this.video && this.video.nativeElement)
            this.video.nativeElement.load();
    }
    getVideoTag() {
        return this.video && this.video.nativeElement ? this.video.nativeElement : null;
    }
    evLoadedMetadata(event) {
        this.videoWidth = this.video.nativeElement.videoWidth;
        this.videoHeight = this.video.nativeElement.videoHeight;
        this.videoLoaded = true;
    }
    evMouseMove(event) {
        this.isMouseMoving = true;
        clearTimeout(this.isMouseMovingTimer);
        this.isMouseMovingTimer = setTimeout(() => {
            this.isMouseMoving = false;
        }, this.isMouseMovingTimeout);
    }
    evTimeUpdate(event) {
        this.time = this.getVideoTag().currentTime;
    }
    getOverlayClass(activeClass, inactiveClass) {
        if (this.overlay === null) {
            return (!this.playing || this.isMouseMoving) ? activeClass : inactiveClass;
        }
        else {
            return this.overlay ? activeClass : inactiveClass;
        }
    }
};
MatVideoComponent.ɵfac = function MatVideoComponent_Factory(t) { return new (t || MatVideoComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatVideoComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatVideoComponent, selectors: [["mat-video"]], viewQuery: function MatVideoComponent_Query(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵviewQuery(_c0, true);
        ɵngcc0.ɵɵviewQuery(_c1, true);
    } if (rf & 2) {
        var _t;
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.player = _t.first);
        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.video = _t.first);
    } }, inputs: { src: "src", title: "title", autoplay: "autoplay", preload: "preload", loop: "loop", quality: "quality", fullscreen: "fullscreen", showFrameByFrame: "showFrameByFrame", fps: "fps", download: "download", color: "color", spinner: "spinner", poster: "poster", keyboard: "keyboard", overlay: "overlay", muted: "muted", time: "time" }, outputs: { mutedChange: "mutedChange", timeChange: "timeChange" }, ngContentSelectors: _c3, decls: 10, vars: 10, consts: [[1, "videoplayer", 3, "ngClass"], ["player", ""], ["class", "header", 3, "ngClass", 4, "ngIf"], [1, "video", 3, "preload"], ["video", ""], ["class", "controls", 3, "ngClass", 4, "ngIf"], [3, "spinner", "video"], [1, "header", 3, "ngClass"], [1, "controls", 3, "ngClass"], [1, "progress"], [3, "color", "video"], [1, "menu"], [1, "left"], [3, "video", "keyboard", "playChanged"], [3, "video", "fps", 4, "ngIf"], [3, "muted", "color", "video", "keyboard", "mutedChanged"], [3, "video"], [1, "right"], [3, "video", 4, "ngIf"], [3, "title", "video", 4, "ngIf"], [3, "player", "keyboard", "fullscreenChanged", 4, "ngIf"], [3, "video", "fps"], [3, "title", "video"], [3, "player", "keyboard", "fullscreenChanged"]], template: function MatVideoComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵprojectionDef(_c2);
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵtemplate(2, MatVideoComponent_div_2_Template, 2, 2, "div", 2);
        ɵngcc0.ɵɵelementStart(3, "video", 3, 4);
        ɵngcc0.ɵɵprojection(5);
        ɵngcc0.ɵɵprojection(6, 1);
        ɵngcc0.ɵɵtext(7, " This browser does not support HTML5 video. ");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵtemplate(8, MatVideoComponent_div_8_Template, 13, 14, "div", 5);
        ɵngcc0.ɵɵelement(9, "mat-video-spinner", 6);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        const _r241 = ɵngcc0.ɵɵreference(4);
        ɵngcc0.ɵɵproperty("ngClass", ctx.getOverlayClass("show-mouse", "hide-mouse"));
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.title);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("preload", ctx.preload ? "auto" : "metadata");
        ɵngcc0.ɵɵattribute("src", ctx.src ? ctx.src : null, ɵngcc0.ɵɵsanitizeUrl)("autoplay", ctx.autoplay ? true : null)("poster", ctx.poster ? ctx.poster : null, ɵngcc0.ɵɵsanitizeUrl)("loop", ctx.loop ? ctx.loop : null);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("ngIf", ctx.videoLoaded);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("spinner", ctx.spinner)("video", _r241);
    } }, directives: function () { return [ɵngcc1.NgClass, ɵngcc1.NgIf, MatVideoSpinnerComponent,
        MatSeekProgressControlComponent,
        MatPlayButtonComponent,
        MatVolumeControlComponent,
        MatTimeControlComponent,
        MatFrameByFrameControlComponent,
        MatQualityControlComponent,
        MatDownloadButtonComponent,
        MatFullscreenButtonComponent]; }, styles: [".videoplayer[_ngcontent-%COMP%]{font-family:Roboto,\"Helvetica Neue\",sans-serif;background-color:#000;position:relative;width:100%;height:100%}.header[_ngcontent-%COMP%]{color:#fff;display:flex;justify-content:center;align-items:center;position:absolute;left:0;top:0;padding:14px 0;width:100%;z-index:1;background-image:linear-gradient(to top,rgba(0,0,0,0),rgba(0,0,0,.65))}.video[_ngcontent-%COMP%]{display:block;width:100%;height:100%;z-index:0}.controls[_ngcontent-%COMP%]{color:#fff;position:absolute;left:0;bottom:0;width:100%;z-index:1;background-image:linear-gradient(to bottom,rgba(0,0,0,0),rgba(0,0,0,.65))}.controls[_ngcontent-%COMP%]   .progress[_ngcontent-%COMP%]{height:26px}.controls[_ngcontent-%COMP%]   .menu[_ngcontent-%COMP%]{display:flex;align-items:center;flex-direction:row;justify-content:space-between;height:48px}.controls[_ngcontent-%COMP%]   .menu[_ngcontent-%COMP%]   .left[_ngcontent-%COMP%]{justify-content:flex-start}.controls[_ngcontent-%COMP%]   .menu[_ngcontent-%COMP%]   .right[_ngcontent-%COMP%]{justify-content:flex-end}.visible[_ngcontent-%COMP%]{visibility:visible;opacity:1;transition:opacity .5s linear}.hidden[_ngcontent-%COMP%]{visibility:hidden;opacity:0;transition:visibility .5s,opacity .5s linear}.show-mouse[_ngcontent-%COMP%]{cursor:default}.hide-mouse[_ngcontent-%COMP%]{cursor:none}", "@font-face{font-family:'Material Icons';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v36/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2) format('woff2')} .material-icons{font-family:'Material Icons';font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;font-feature-settings:'liga';-webkit-font-feature-settings:'liga';-webkit-font-smoothing:antialiased}"] });
__decorate([
    ViewChild('player'),
    __metadata("design:type", ElementRef)
], MatVideoComponent.prototype, "player", void 0);
__decorate([
    ViewChild('video'),
    __metadata("design:type", ElementRef)
], MatVideoComponent.prototype, "video", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoComponent.prototype, "src", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoComponent.prototype, "title", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVideoComponent.prototype, "autoplay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVideoComponent.prototype, "preload", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVideoComponent.prototype, "loop", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVideoComponent.prototype, "quality", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVideoComponent.prototype, "fullscreen", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVideoComponent.prototype, "showFrameByFrame", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MatVideoComponent.prototype, "fps", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVideoComponent.prototype, "download", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoComponent.prototype, "spinner", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoComponent.prototype, "poster", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVideoComponent.prototype, "keyboard", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVideoComponent.prototype, "overlay", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVideoComponent.prototype, "muted", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], MatVideoComponent.prototype, "mutedChange", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], MatVideoComponent.prototype, "time", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], MatVideoComponent.prototype, "timeChange", void 0);
MatVideoComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        EventService])
], MatVideoComponent);

let MatVideoSourceDirective = class MatVideoSourceDirective {
    constructor(matVideoComponent, el) {
        this.matVideoComponent = matVideoComponent;
        this.el = el;
        this.src = null;
        this.type = null;
        this.init = true;
        this.video = matVideoComponent;
        this.source = el.nativeElement;
        this.init = false;
    }
    ngOnChanges(changes) {
        this.source.src = this.src;
        this.source.type = this.type;
        if (!this.init)
            this.video.load();
    }
};
MatVideoSourceDirective.ɵfac = function MatVideoSourceDirective_Factory(t) { return new (t || MatVideoSourceDirective)(ɵngcc0.ɵɵdirectiveInject(MatVideoComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MatVideoSourceDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatVideoSourceDirective, selectors: [["", "matVideoSource", ""]], inputs: { src: "src", type: "type" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoSourceDirective.prototype, "src", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoSourceDirective.prototype, "type", void 0);
MatVideoSourceDirective = __decorate([ __param(0, Host()),
    __metadata("design:paramtypes", [MatVideoComponent,
        ElementRef])
], MatVideoSourceDirective);

let MatVideoTrackDirective = class MatVideoTrackDirective {
    constructor(matVideoComponent, el) {
        this.matVideoComponent = matVideoComponent;
        this.el = el;
        this.src = null;
        this.kind = null;
        this.srclang = null;
        this.label = null;
        this.init = true;
        this.video = matVideoComponent;
        this.track = el.nativeElement;
        this.init = false;
    }
    ngOnChanges(changes) {
        this.track.src = this.src;
        this.track.kind = this.kind;
        this.track.srclang = this.srclang;
        this.track.label = this.label;
        if (!this.init)
            this.video.load();
    }
};
MatVideoTrackDirective.ɵfac = function MatVideoTrackDirective_Factory(t) { return new (t || MatVideoTrackDirective)(ɵngcc0.ɵɵdirectiveInject(MatVideoComponent, 1), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef)); };
MatVideoTrackDirective.ɵdir = ɵngcc0.ɵɵdefineDirective({ type: MatVideoTrackDirective, selectors: [["", "matVideoTrack", ""]], inputs: { src: "src", kind: "kind", srclang: "srclang", label: "label" }, features: [ɵngcc0.ɵɵNgOnChangesFeature()] });
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoTrackDirective.prototype, "src", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoTrackDirective.prototype, "kind", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoTrackDirective.prototype, "srclang", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoTrackDirective.prototype, "label", void 0);
MatVideoTrackDirective = __decorate([ __param(0, Host()),
    __metadata("design:paramtypes", [MatVideoComponent,
        ElementRef])
], MatVideoTrackDirective);

/** Counter used to generate unique IDs for progress bars. */
let sliderprogressbarId = 0;
let MatSliderProgressBarComponent = class MatSliderProgressBarComponent extends MatSlider {
    constructor(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex) {
        super(elementRef, focusMonitor, changeDetectorRef, dir, tabIndex);
        this.mode = 'buffer';
        this.value = 0;
        this._bufferValue = 0;
        /** The id of the progress bar. */
        this.sliderprogressbarId = `mat-slider-progress-bar-${sliderprogressbarId++}`;
        this.tabIndex = parseInt(tabIndex) || 0;
    }
    /** Buffer value of the progress bar. Defaults to zero. */
    get bufferValue() { return this._bufferValue; }
    set bufferValue(v) { this._bufferValue = clamp(v || 0); }
    /** CSS styles for the track fill element. */
    get _trackBufferStyles() {
        if (this.mode === 'buffer') {
            const axis = this.vertical ? 'Y' : 'X';
            return {
                'transform': `translate${axis}(0px) scale${axis}(${this._bufferValue / 100})`
            };
        }
    }
};
MatSliderProgressBarComponent.ɵfac = function MatSliderProgressBarComponent_Factory(t) { return new (t || MatSliderProgressBarComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc2.FocusMonitor), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc3.Directionality, 8), ɵngcc0.ɵɵinjectAttribute('tabindex')); };
MatSliderProgressBarComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSliderProgressBarComponent, selectors: [["mat-slider-progress-bar"]], hostAttrs: ["role", "slider", 1, "mat-slider"], hostVars: 24, hostBindings: function MatSliderProgressBarComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("focus", function MatSliderProgressBarComponent_focus_HostBindingHandler($event) { return ctx._onFocus(); })("blur", function MatSliderProgressBarComponent_blur_HostBindingHandler($event) { return ctx._onBlur(); })("click", function MatSliderProgressBarComponent_click_HostBindingHandler($event) { return ctx["_onClick"] ? ctx["_onClick"]($event) : null; })("mousedown", function MatSliderProgressBarComponent_mousedown_HostBindingHandler($event) { return ctx["_onMousedown"] ? ctx["_onMousedown"]($event) : null; })("keydown", function MatSliderProgressBarComponent_keydown_HostBindingHandler($event) { return ctx._onKeydown($event); })("keyup", function MatSliderProgressBarComponent_keyup_HostBindingHandler($event) { return ctx._onKeyup(); })("mouseenter", function MatSliderProgressBarComponent_mouseenter_HostBindingHandler($event) { return ctx._onMouseenter(); })("slide", function MatSliderProgressBarComponent_slide_HostBindingHandler($event) { return ctx._onSlide($event); })("slideend", function MatSliderProgressBarComponent_slideend_HostBindingHandler($event) { return ctx._onSlideEnd(); })("slidestart", function MatSliderProgressBarComponent_slidestart_HostBindingHandler($event) { return ctx._onSlideStart($event); });
    } if (rf & 2) {
        ɵngcc0.ɵɵhostProperty("tabIndex", ctx.tabIndex);
        ɵngcc0.ɵɵattribute("aria-disabled", ctx.disabled)("aria-valuemax", ctx.max)("aria-valuemin", ctx.min)("aria-valuenow", ctx.value)("aria-orientation", ctx.vertical ? "vertical" : "horizontal");
        ɵngcc0.ɵɵclassProp("mat-slider-disabled", ctx.disabled)("mat-slider-has-ticks", ctx.tickInterval)("mat-slider-horizontal", !ctx.vertical)("mat-slider-axis-inverted", ctx._invertAxis)("mat-slider-sliding", ctx._isSliding)("mat-slider-thumb-label-showing", ctx.thumbLabel)("mat-slider-vertical", ctx.vertical)("mat-slider-min-value", ctx._isMinValue)("mat-slider-hide-last-tick", ctx.disabled || ctx._isMinValue && ctx._thumbGap && ctx._invertAxis);
    } }, inputs: { disabled: "disabled", color: "color", tabIndex: "tabIndex", mode: "mode", value: "value", bufferValue: "bufferValue" }, features: [ɵngcc0.ɵɵProvidersFeature([MAT_SLIDER_VALUE_ACCESSOR]), ɵngcc0.ɵɵInheritDefinitionFeature], decls: 18, vars: 8, consts: [[1, "mat-slider-wrapper"], ["sliderWrapper", ""], [1, "mat-slider-track-wrapper"], ["width", "100%", "height", "2", "focusable", "false", 1, "mat-slider-progress-background"], ["x", "2.5", "y", "0", "width", "5", "height", "2.5", "patternUnits", "userSpaceOnUse", 3, "id"], ["cx", "1.25", "cy", "1.25", "r", "1.25"], ["width", "100%", "height", "100%"], [1, "mat-slider-track-fill", "mat-slider-track-buffer", 3, "ngStyle"], [1, "mat-slider-track-fill", 3, "ngStyle"], [1, "mat-slider-ticks-container", 3, "ngStyle"], [1, "mat-slider-ticks", 3, "ngStyle"], [1, "mat-slider-thumb-container", 3, "ngStyle"], [1, "mat-slider-focus-ring"], [1, "mat-slider-thumb"], [1, "mat-slider-thumb-label"], [1, "mat-slider-thumb-label-text"]], template: function MatSliderProgressBarComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0, 1);
        ɵngcc0.ɵɵelementStart(2, "div", 2);
        ɵngcc0.ɵɵnamespaceSVG();
        ɵngcc0.ɵɵelementStart(3, "svg", 3);
        ɵngcc0.ɵɵelementStart(4, "defs");
        ɵngcc0.ɵɵelementStart(5, "pattern", 4);
        ɵngcc0.ɵɵelement(6, "circle", 5);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelement(7, "rect", 6);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵnamespaceHTML();
        ɵngcc0.ɵɵelement(8, "div", 7);
        ɵngcc0.ɵɵelement(9, "div", 8);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(10, "div", 9);
        ɵngcc0.ɵɵelement(11, "div", 10);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(12, "div", 11);
        ɵngcc0.ɵɵelement(13, "div", 12);
        ɵngcc0.ɵɵelement(14, "div", 13);
        ɵngcc0.ɵɵelementStart(15, "div", 14);
        ɵngcc0.ɵɵelementStart(16, "span", 15);
        ɵngcc0.ɵɵtext(17);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵproperty("id", ctx.sliderprogressbarId);
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵattribute("fill", "url(#" + ctx.sliderprogressbarId + ")");
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._trackBufferStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._trackFillStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._ticksContainerStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._ticksStyles);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngStyle", ctx._thumbContainerStyles);
        ɵngcc0.ɵɵadvance(5);
        ɵngcc0.ɵɵtextInterpolate(ctx.displayValue);
    } }, directives: [ɵngcc1.NgStyle], styles: ["[_nghost-%COMP%]{width:100%}.mat-slider-progress-background[_ngcontent-%COMP%]{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer[_ngcontent-%COMP%]{background-color:#d3d3d3!important}.mat-slider-thumb[_ngcontent-%COMP%]{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}[_nghost-%COMP%]:hover   .mat-slider-thumb[_ngcontent-%COMP%]{visibility:visible;opacity:1;transition:opacity .2s linear}"], changeDetection: 0 });
__decorate([
    Input(),
    __metadata("design:type", String)
], MatSliderProgressBarComponent.prototype, "mode", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MatSliderProgressBarComponent.prototype, "value", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], MatSliderProgressBarComponent.prototype, "bufferValue", null);
MatSliderProgressBarComponent = __decorate([ __param(3, Optional()),
    __param(4, Attribute('tabindex')),
    __metadata("design:paramtypes", [ElementRef,
        FocusMonitor,
        ChangeDetectorRef,
        Directionality, String])
], MatSliderProgressBarComponent);
/** Clamps a value to be between two numbers, by default 0 and 100. */
function clamp(v, min = 0, max = 100) {
    return Math.max(min, Math.min(max, v));
}

let SecondsToTimePipe = class SecondsToTimePipe {
    constructor() {
        this.times = {
            year: 31557600,
            month: 2629746,
            day: 86400,
            hour: 3600,
        };
    }
    transform(seconds) {
        if (!seconds)
            return '0:00';
        else {
            let time_string = '';
            for (const key in this.times) {
                if (Math.floor(seconds / this.times[key]) > 0) {
                    time_string += Math.floor(seconds / this.times[key]).toString() + ':';
                    seconds = seconds - this.times[key] * Math.floor(seconds / this.times[key]);
                }
            }
            time_string += Math.floor(seconds / 60).toString() + ':';
            seconds = seconds - 60 * Math.floor(seconds / 60);
            if (Math.floor(seconds) < 10)
                time_string += '0';
            time_string += Math.floor(seconds).toString();
            return time_string;
        }
    }
};
SecondsToTimePipe.ɵfac = function SecondsToTimePipe_Factory(t) { return new (t || SecondsToTimePipe)(); };
SecondsToTimePipe.ɵpipe = ɵngcc0.ɵɵdefinePipe({ name: "secondsToTime", type: SecondsToTimePipe, pure: true });

let FullscreenService = class FullscreenService {
    constructor() {
        this.fnMap = [
            // Object keys
            [
                'requestFullscreen',
                'exitFullscreen',
                'fullscreenElement',
                'fullscreenEnabled',
                'fullscreenchange',
                'fullscreenerror'
            ],
            // New WebKit
            [
                'webkitRequestFullscreen',
                'webkitExitFullscreen',
                'webkitFullscreenElement',
                'webkitFullscreenEnabled',
                'webkitfullscreenchange',
                'webkitfullscreenerror'
            ],
            // Old WebKit (Safari 5.1)
            [
                'webkitRequestFullScreen',
                'webkitCancelFullScreen',
                'webkitCurrentFullScreenElement',
                'webkitCancelFullScreen',
                'webkitfullscreenchange',
                'webkitfullscreenerror'
            ],
            // Mozilla
            [
                'mozRequestFullScreen',
                'mozCancelFullScreen',
                'mozFullScreenElement',
                'mozFullScreenEnabled',
                'mozfullscreenchange',
                'mozfullscreenerror'
            ],
            // MS
            [
                'msRequestFullscreen',
                'msExitFullscreen',
                'msFullscreenElement',
                'msFullscreenEnabled',
                'MSFullscreenChange',
                'MSFullscreenError'
            ]
        ];
        this.keyboardAllowed = typeof Element !== 'undefined' && 'ALLOW_KEYBOARD_INPUT' in Element;
        const ret = {};
        let val;
        for (let i = 0; i < this.fnMap.length; i++) {
            val = this.fnMap[i];
            if (val && val[1] in document) {
                for (i = 0; i < val.length; i++) {
                    // Map everything to the first list of keys
                    ret[this.fnMap[0][i].toString()] = val[i];
                }
                this.fn = ret;
            }
        }
    }
    request(elem) {
        const request = this.fn.requestFullscreen;
        elem = elem || document.documentElement;
        // Work around Safari 5.1 bug: reports support for
        // keyboard in fullscreen even though it doesn't.
        // Browser sniffing, since the alternative with
        // setTimeout is even worse.
        if (/5\.1[.\d]* Safari/.test(navigator.userAgent)) {
            elem[request]();
        }
        else {
            elem[request](this.keyboardAllowed ? Element.ALLOW_KEYBOARD_INPUT : {});
        }
    }
    exit() {
        document[this.fn.exitFullscreen]();
    }
    toggle(elem) {
        if (this.isFullscreen()) {
            this.exit();
        }
        else {
            this.request(elem);
        }
    }
    onChange(callback) {
        document.addEventListener(this.fn.fullscreenchange, callback, false);
    }
    onError(callback) {
        document.addEventListener(this.fn.fullscreenerror, callback, false);
    }
    isFullscreen() {
        return Boolean(document[this.fn.fullscreenElement]);
    }
    isEnabled() {
        // Coerce to boolean in case of old WebKit
        return Boolean(document[this.fn.fullscreenEnabled]);
    }
    getElement() {
        return document[this.fn.fullscreenElement];
    }
};
FullscreenService.ɵfac = function FullscreenService_Factory(t) { return new (t || FullscreenService)(); };
FullscreenService.ɵprov = ɵngcc0.ɵɵdefineInjectable({ token: FullscreenService, factory: FullscreenService.ɵfac });
FullscreenService = __decorate([ __metadata("design:paramtypes", [])
], FullscreenService);

let MatDownloadButtonComponent = class MatDownloadButtonComponent {
    constructor() { }
};
MatDownloadButtonComponent.ɵfac = function MatDownloadButtonComponent_Factory(t) { return new (t || MatDownloadButtonComponent)(); };
MatDownloadButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatDownloadButtonComponent, selectors: [["mat-download-button"]], inputs: { video: "video", title: "title" }, decls: 3, vars: 2, consts: [["mat-icon-button", "", 3, "href", "download"]], template: function MatDownloadButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "a", 0);
        ɵngcc0.ɵɵelementStart(1, "mat-icon");
        ɵngcc0.ɵɵtext(2, "file_download");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("href", ctx.video == null ? null : ctx.video.currentSrc, ɵngcc0.ɵɵsanitizeUrl)("download", ctx.title);
    } }, directives: [ɵngcc4.MatAnchor, ɵngcc5.MatIcon], styles: ["a[_ngcontent-%COMP%]{color:inherit;text-decoration:none}"] });
__decorate([
    Input(),
    __metadata("design:type", HTMLVideoElement)
], MatDownloadButtonComponent.prototype, "video", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatDownloadButtonComponent.prototype, "title", void 0);
MatDownloadButtonComponent = __decorate([ __metadata("design:paramtypes", [])
], MatDownloadButtonComponent);

let MatFrameByFrameControlComponent = class MatFrameByFrameControlComponent {
    constructor() {
        this.fps = 29.97;
    }
    ngOnInit() {
    }
    seekFrames(nbFrames) {
        if (!this.video.paused) {
            this.video.pause();
        }
        const currentFrames = this.video.currentTime * this.fps;
        const newPos = ((currentFrames + nbFrames) / this.fps) + 0.00001;
        this.video.currentTime = newPos;
    }
};
MatFrameByFrameControlComponent.ɵfac = function MatFrameByFrameControlComponent_Factory(t) { return new (t || MatFrameByFrameControlComponent)(); };
MatFrameByFrameControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatFrameByFrameControlComponent, selectors: [["mat-frame-by-frame-control"]], inputs: { fps: "fps", video: "video" }, decls: 12, vars: 0, consts: [["mat-icon-button", "", 3, "click"]], template: function MatFrameByFrameControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_0_listener($event) { return ctx.seekFrames(0 - 5); });
        ɵngcc0.ɵɵelementStart(1, "mat-icon");
        ɵngcc0.ɵɵtext(2, "skip_previous");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(3, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_3_listener($event) { return ctx.seekFrames(0 - 1); });
        ɵngcc0.ɵɵelementStart(4, "mat-icon");
        ɵngcc0.ɵɵtext(5, "arrow_left");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_6_listener($event) { return ctx.seekFrames(1); });
        ɵngcc0.ɵɵelementStart(7, "mat-icon");
        ɵngcc0.ɵɵtext(8, "arrow_right");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(9, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFrameByFrameControlComponent_Template_button_click_9_listener($event) { return ctx.seekFrames(5); });
        ɵngcc0.ɵɵelementStart(10, "mat-icon");
        ɵngcc0.ɵɵtext(11, "skip_next");
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } }, directives: [ɵngcc4.MatButton, ɵngcc5.MatIcon], styles: [""] });
__decorate([
    Input(),
    __metadata("design:type", HTMLVideoElement)
], MatFrameByFrameControlComponent.prototype, "video", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MatFrameByFrameControlComponent.prototype, "fps", void 0);
MatFrameByFrameControlComponent = __decorate([ __metadata("design:paramtypes", [])
], MatFrameByFrameControlComponent);

let MatFullscreenButtonComponent = class MatFullscreenButtonComponent {
    constructor(fscreen, evt) {
        this.fscreen = fscreen;
        this.evt = evt;
        this.canFullscreen = false;
        this.fullscreen = false;
        this.fullscreenChanged = new EventEmitter();
        this.keyboard = true;
    }
    ngOnInit() {
        if (this.fscreen.isEnabled())
            this.canFullscreen = true;
        this.fscreen.onChange(event => this.fscreen.isFullscreen() ? this.onChangesFullscreen(true) : this.onChangesFullscreen(false));
    }
    setFullscreen(value) {
        if (this.canFullscreen && this.fullscreen !== value)
            this.toggleFullscreen();
    }
    toggleFullscreen() {
        this.fullscreen = !this.fullscreen;
        this.updateFullscreen();
    }
    updateFullscreen() {
        this.fullscreen ? this.fscreen.request(this.player) : this.fscreen.exit();
        this.fullscreenChanged.emit(this.fullscreen);
    }
    onChangesFullscreen(value) {
        this.fullscreen = value;
        this.fullscreenChanged.emit(this.fullscreen);
    }
    onFullscreenKey(event) {
        if (this.keyboard) {
            this.toggleFullscreen();
            event.preventDefault();
        }
    }
};
MatFullscreenButtonComponent.ɵfac = function MatFullscreenButtonComponent_Factory(t) { return new (t || MatFullscreenButtonComponent)(ɵngcc0.ɵɵdirectiveInject(FullscreenService), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatFullscreenButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatFullscreenButtonComponent, selectors: [["mat-fullscreen-button"]], hostBindings: function MatFullscreenButtonComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.f", function MatFullscreenButtonComponent_keyup_f_HostBindingHandler($event) { return ctx.onFullscreenKey($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { fullscreen: "fullscreen", keyboard: "keyboard", player: "player" }, outputs: { fullscreenChanged: "fullscreenChanged" }, decls: 3, vars: 3, consts: [["mat-icon-button", "", 3, "disabled", "click"], [4, "ngIf"]], template: function MatFullscreenButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatFullscreenButtonComponent_Template_button_click_0_listener($event) { return ctx.toggleFullscreen(); });
        ɵngcc0.ɵɵtemplate(1, MatFullscreenButtonComponent_mat_icon_1_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵtemplate(2, MatFullscreenButtonComponent_mat_icon_2_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("disabled", !ctx.canFullscreen);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.fullscreen);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.fullscreen);
    } }, directives: [ɵngcc4.MatButton, ɵngcc1.NgIf, ɵngcc5.MatIcon], styles: [""] });
__decorate([
    Input(),
    __metadata("design:type", HTMLVideoElement)
], MatFullscreenButtonComponent.prototype, "player", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatFullscreenButtonComponent.prototype, "fullscreen", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], MatFullscreenButtonComponent.prototype, "fullscreenChanged", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatFullscreenButtonComponent.prototype, "keyboard", void 0);
__decorate([
    HostListener('document:keyup.f', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], MatFullscreenButtonComponent.prototype, "onFullscreenKey", null);
MatFullscreenButtonComponent = __decorate([ __metadata("design:paramtypes", [FullscreenService,
        EventService])
], MatFullscreenButtonComponent);

let MatPlayButtonComponent = class MatPlayButtonComponent {
    constructor(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.play = false;
        this.playChanged = new EventEmitter();
        this.keyboard = true;
    }
    ngAfterViewInit() {
        this.events = [
            { element: this.video, name: 'play', callback: event => this.setVideoPlayback(true), dispose: null },
            { element: this.video, name: 'pause', callback: event => this.setVideoPlayback(false), dispose: null },
            { element: this.video, name: 'durationchange', callback: event => this.setVideoPlayback(false), dispose: null },
            { element: this.video, name: 'ended', callback: event => this.setVideoPlayback(false), dispose: null },
            { element: this.video, name: 'click', callback: event => this.toggleVideoPlayback(), dispose: null }
        ];
        this.evt.addEvents(this.renderer, this.events);
    }
    ngOnDestroy() {
        this.evt.removeEvents(this.events);
    }
    setVideoPlayback(value) {
        if (this.play !== value)
            this.toggleVideoPlayback();
    }
    toggleVideoPlayback() {
        this.play = !this.play;
        this.updateVideoPlayback();
    }
    updateVideoPlayback() {
        this.play ? this.video.play() : this.video.pause();
        this.playChanged.emit(this.play);
    }
    onPlayKey(event) {
        if (this.keyboard) {
            this.toggleVideoPlayback();
            event.preventDefault();
        }
    }
};
MatPlayButtonComponent.ɵfac = function MatPlayButtonComponent_Factory(t) { return new (t || MatPlayButtonComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatPlayButtonComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatPlayButtonComponent, selectors: [["mat-play-button"]], hostBindings: function MatPlayButtonComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.space", function MatPlayButtonComponent_keyup_space_HostBindingHandler($event) { return ctx.onPlayKey($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { play: "play", keyboard: "keyboard", video: "video" }, outputs: { playChanged: "playChanged" }, decls: 3, vars: 2, consts: [["mat-icon-button", "", 3, "click"], [4, "ngIf"]], template: function MatPlayButtonComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "button", 0);
        ɵngcc0.ɵɵlistener("click", function MatPlayButtonComponent_Template_button_click_0_listener($event) { return ctx.toggleVideoPlayback(); });
        ɵngcc0.ɵɵtemplate(1, MatPlayButtonComponent_mat_icon_1_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵtemplate(2, MatPlayButtonComponent_mat_icon_2_Template, 2, 0, "mat-icon", 1);
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.play);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", ctx.play);
    } }, directives: [ɵngcc4.MatButton, ɵngcc1.NgIf, ɵngcc5.MatIcon], styles: [""] });
__decorate([
    Input(),
    __metadata("design:type", HTMLVideoElement)
], MatPlayButtonComponent.prototype, "video", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatPlayButtonComponent.prototype, "play", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], MatPlayButtonComponent.prototype, "playChanged", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatPlayButtonComponent.prototype, "keyboard", void 0);
__decorate([
    HostListener('document:keyup.space', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], MatPlayButtonComponent.prototype, "onPlayKey", null);
MatPlayButtonComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        EventService])
], MatPlayButtonComponent);

let MatQualityControlComponent = class MatQualityControlComponent {
    constructor() { }
};
MatQualityControlComponent.ɵfac = function MatQualityControlComponent_Factory(t) { return new (t || MatQualityControlComponent)(); };
MatQualityControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatQualityControlComponent, selectors: [["mat-quality-control"]], inputs: { video: "video" }, decls: 1, vars: 1, consts: [["class", "quality", 4, "ngIf"], [1, "quality"]], template: function MatQualityControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, MatQualityControlComponent_div_0_Template, 2, 1, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", ctx.video && ctx.video.videoHeight);
    } }, directives: [ɵngcc1.NgIf], styles: [".quality[_ngcontent-%COMP%]{display:inline-block;font-size:12px;padding-left:12px;padding-right:12px}"] });
__decorate([
    Input(),
    __metadata("design:type", HTMLVideoElement)
], MatQualityControlComponent.prototype, "video", void 0);
MatQualityControlComponent = __decorate([ __metadata("design:paramtypes", [])
], MatQualityControlComponent);

let MatSeekProgressControlComponent = class MatSeekProgressControlComponent {
    constructor(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.curTimePercent = 0;
        this.bufTimePercent = 0;
        this.video = null;
        this.color = 'primary';
        this.currentTime = 0;
        this.currentTimeChanged = new EventEmitter();
        this.bufferedTime = 0;
        this.bufferedTimeChanged = new EventEmitter();
    }
    ngAfterViewInit() {
        this.events = [
            { element: this.video, name: 'seeking', callback: event => this.updateCurrentTime(this.video.currentTime), dispose: null },
            { element: this.video, name: 'canplaythrough', callback: event => this.updateBufferedTime(), dispose: null },
            { element: this.video, name: 'timeupdate', callback: event => this.updateCurrentTime(this.video.currentTime), dispose: null },
            { element: this.video, name: 'progress', callback: event => this.updateBufferedTime(), dispose: null }
        ];
        this.evt.addEvents(this.renderer, this.events);
    }
    ngOnDestroy() {
        this.evt.removeEvents(this.events);
    }
    seekVideo(value) {
        const percentage = value / 100;
        const newTime = this.video.duration * percentage;
        this.video.currentTime = newTime;
    }
    updateCurrentTime(time) {
        this.currentTime = time;
        this.curTimePercent = this.updateTime(this.currentTimeChanged, this.currentTime);
    }
    updateBufferedTime() {
        if (this.video.buffered.length > 0) {
            let largestBufferValue = 0;
            for (let i = 0; i < this.video.buffered.length; i++) {
                const cur = this.video.currentTime;
                const start = this.video.buffered.start(i);
                const end = this.video.buffered.end(i);
                if (start <= cur && end > cur && (end - start) > largestBufferValue)
                    largestBufferValue = end;
            }
            this.bufferedTime = largestBufferValue;
            this.bufTimePercent = this.updateTime(this.bufferedTimeChanged, this.bufferedTime);
        }
    }
    updateTime(emitter, time) {
        emitter.emit(time);
        return time / this.video.duration * 100;
    }
};
MatSeekProgressControlComponent.ɵfac = function MatSeekProgressControlComponent_Factory(t) { return new (t || MatSeekProgressControlComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatSeekProgressControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatSeekProgressControlComponent, selectors: [["mat-seek-progress-control"]], inputs: { video: "video", color: "color", currentTime: "currentTime", bufferedTime: "bufferedTime" }, outputs: { currentTimeChanged: "currentTimeChanged", bufferedTimeChanged: "bufferedTimeChanged" }, decls: 1, vars: 3, consts: [["mode", "buffer", "step", "0.01", 3, "color", "value", "bufferValue", "input"]], template: function MatSeekProgressControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "mat-slider-progress-bar", 0);
        ɵngcc0.ɵɵlistener("input", function MatSeekProgressControlComponent_Template_mat_slider_progress_bar_input_0_listener($event) { return ctx.seekVideo($event.value); });
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("color", ctx.color)("value", ctx.curTimePercent)("bufferValue", ctx.bufTimePercent);
    } }, directives: [MatSliderProgressBarComponent], styles: [""] });
__decorate([
    Input(),
    __metadata("design:type", HTMLVideoElement)
], MatSeekProgressControlComponent.prototype, "video", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatSeekProgressControlComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MatSeekProgressControlComponent.prototype, "currentTime", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], MatSeekProgressControlComponent.prototype, "currentTimeChanged", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MatSeekProgressControlComponent.prototype, "bufferedTime", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], MatSeekProgressControlComponent.prototype, "bufferedTimeChanged", void 0);
MatSeekProgressControlComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        EventService])
], MatSeekProgressControlComponent);

let MatTimeControlComponent = class MatTimeControlComponent {
    constructor() { }
};
MatTimeControlComponent.ɵfac = function MatTimeControlComponent_Factory(t) { return new (t || MatTimeControlComponent)(); };
MatTimeControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatTimeControlComponent, selectors: [["mat-time-control"]], inputs: { video: "video" }, decls: 4, vars: 6, consts: [[1, "playtime"]], template: function MatTimeControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵtext(1);
        ɵngcc0.ɵɵpipe(2, "secondsToTime");
        ɵngcc0.ɵɵpipe(3, "secondsToTime");
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵtextInterpolate2(" ", ɵngcc0.ɵɵpipeBind1(2, 2, ctx.video == null ? null : ctx.video.currentTime), " / ", ɵngcc0.ɵɵpipeBind1(3, 4, ctx.video == null ? null : ctx.video.duration), "\n");
    } }, pipes: [SecondsToTimePipe], styles: [".playtime[_ngcontent-%COMP%]{display:inline;font-size:12px}"] });
__decorate([
    Input(),
    __metadata("design:type", HTMLVideoElement)
], MatTimeControlComponent.prototype, "video", void 0);
MatTimeControlComponent = __decorate([ __metadata("design:paramtypes", [])
], MatTimeControlComponent);

let MatVideoSpinnerComponent = class MatVideoSpinnerComponent {
    constructor(renderer, evt) {
        this.renderer = renderer;
        this.evt = evt;
        this.spinner = 'spin';
        this.videoBuffering = false;
        this.videoLoaded = false;
        this.events = [];
    }
    ngAfterViewInit() {
        this.events = [
            { element: this.video, name: 'loadstart', callback: event => this.videoLoaded = false, dispose: null },
            { element: this.video, name: 'loadedmetadata', callback: event => this.videoLoaded = true, dispose: null },
            { element: this.video, name: 'canplay', callback: event => this.videoBuffering = false, dispose: null },
            { element: this.video, name: 'waiting', callback: event => this.videoBuffering = true, dispose: null },
            { element: this.video, name: 'durationchange', callback: event => this.videoBuffering = true, dispose: null }
        ];
        this.video.onloadeddata = () => this.videoLoaded = true;
        this.evt.addEvents(this.renderer, this.events);
    }
    ngOnDestroy() {
        this.video.onloadeddata = null;
        this.evt.removeEvents(this.events);
    }
};
MatVideoSpinnerComponent.ɵfac = function MatVideoSpinnerComponent_Factory(t) { return new (t || MatVideoSpinnerComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.Renderer2), ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatVideoSpinnerComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatVideoSpinnerComponent, selectors: [["mat-video-spinner"]], inputs: { spinner: "spinner", video: "video" }, decls: 1, vars: 1, consts: [[3, "class", 4, "ngIf"]], template: function MatVideoSpinnerComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵtemplate(0, MatVideoSpinnerComponent_div_0_Template, 1, 2, "div", 0);
    } if (rf & 2) {
        ɵngcc0.ɵɵproperty("ngIf", !ctx.videoLoaded || ctx.videoBuffering);
    } }, directives: [ɵngcc1.NgIf], styles: ["[_nghost-%COMP%]{position:absolute;left:calc(50% - 32px);top:calc(50% - 32px);z-index:1}", ".spin[_ngcontent-%COMP%]{box-sizing:border-box;width:64px;height:64px;border-radius:100%;border:10px solid rgba(255,255,255,.2);border-top-color:#fff;-webkit-animation:1s linear infinite spin;animation:1s linear infinite spin}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}", ".dot[_ngcontent-%COMP%]{width:64px;height:64px;background-color:#fff;border-radius:100%;-webkit-animation:1s ease-in-out infinite dot;animation:1s ease-in-out infinite dot}@-webkit-keyframes dot{0%{-webkit-transform:scale(0)}100%{-webkit-transform:scale(1);opacity:0}}@keyframes dot{0%{-webkit-transform:scale(0);transform:scale(0)}100%{-webkit-transform:scale(1);transform:scale(1);opacity:0}}", ".split-ring[_ngcontent-%COMP%]{display:inline-block;width:64px;height:64px}.split-ring[_ngcontent-%COMP%]:after{content:\" \";display:block;width:46px;height:46px;margin:1px;border-radius:50%;border:5px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s linear infinite split-ring;animation:1.2s linear infinite split-ring}@-webkit-keyframes split-ring{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes split-ring{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}", ".hourglass[_ngcontent-%COMP%]{display:inline-block;position:relative;width:64px;height:64px}.hourglass[_ngcontent-%COMP%]:after{content:\" \";display:block;border-radius:50%;width:0;height:0;margin:6px;box-sizing:border-box;border:26px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s infinite hourglass;animation:1.2s infinite hourglass}@-webkit-keyframes hourglass{0%{-webkit-transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{-webkit-transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{-webkit-transform:rotate(720deg)}}@keyframes hourglass{0%{-webkit-transform:rotate(0);transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{-webkit-transform:rotate(360deg);transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{-webkit-transform:rotate(720deg);transform:rotate(720deg)}}"] });
__decorate([
    Input(),
    __metadata("design:type", HTMLVideoElement)
], MatVideoSpinnerComponent.prototype, "video", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVideoSpinnerComponent.prototype, "spinner", void 0);
MatVideoSpinnerComponent = __decorate([ __metadata("design:paramtypes", [Renderer2,
        EventService])
], MatVideoSpinnerComponent);

let MatVolumeControlComponent = class MatVolumeControlComponent {
    constructor(evt) {
        this.evt = evt;
        this.video = null;
        this.color = 'primary';
        this.volume = 1;
        this.volumeChanged = new EventEmitter();
        this._muted = false;
        this.mutedChanged = new EventEmitter();
        this.keyboard = true;
    }
    get muted() { return this._muted; }
    set muted(v) {
        this._muted = v;
        this.video.muted = this._muted;
    }
    setVolume(value) {
        this.volume = value;
        this.video.volume = this.volume;
        this.volumeChanged.emit(this.volume);
        if (this.volume > 0)
            this.setMuted(false);
    }
    setMuted(value) {
        if (this.muted !== value)
            this.toggleMuted();
    }
    toggleMuted() {
        this.muted = !this.muted;
        this.updateMuted();
    }
    updateMuted() {
        this.video.muted = this.muted;
        this.mutedChanged.emit(this.muted);
    }
    onMuteKey(event) {
        if (this.keyboard) {
            this.toggleMuted();
            event.preventDefault();
        }
    }
};
MatVolumeControlComponent.ɵfac = function MatVolumeControlComponent_Factory(t) { return new (t || MatVolumeControlComponent)(ɵngcc0.ɵɵdirectiveInject(EventService)); };
MatVolumeControlComponent.ɵcmp = ɵngcc0.ɵɵdefineComponent({ type: MatVolumeControlComponent, selectors: [["mat-volume-control"]], hostBindings: function MatVolumeControlComponent_HostBindings(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵlistener("keyup.m", function MatVolumeControlComponent_keyup_m_HostBindingHandler($event) { return ctx.onMuteKey($event); }, false, ɵngcc0.ɵɵresolveDocument);
    } }, inputs: { video: "video", color: "color", volume: "volume", keyboard: "keyboard", muted: "muted" }, outputs: { volumeChanged: "volumeChanged", mutedChanged: "mutedChanged" }, decls: 7, vars: 5, consts: [[1, "volume-control"], ["mat-icon-button", "", 3, "click"], [4, "ngIf"], ["min", "0", "max", "1", "step", "0.01", "value", "1", 1, "volume-slider", 3, "color", "input"]], template: function MatVolumeControlComponent_Template(rf, ctx) { if (rf & 1) {
        ɵngcc0.ɵɵelementStart(0, "div", 0);
        ɵngcc0.ɵɵelementStart(1, "button", 1);
        ɵngcc0.ɵɵlistener("click", function MatVolumeControlComponent_Template_button_click_1_listener($event) { return ctx.toggleMuted(); });
        ɵngcc0.ɵɵtemplate(2, MatVolumeControlComponent_mat_icon_2_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵtemplate(3, MatVolumeControlComponent_mat_icon_3_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵtemplate(4, MatVolumeControlComponent_mat_icon_4_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵtemplate(5, MatVolumeControlComponent_mat_icon_5_Template, 2, 0, "mat-icon", 2);
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementStart(6, "mat-slider", 3);
        ɵngcc0.ɵɵlistener("input", function MatVolumeControlComponent_Template_mat_slider_input_6_listener($event) { return ctx.setVolume($event.value); });
        ɵngcc0.ɵɵelementEnd();
        ɵngcc0.ɵɵelementEnd();
    } if (rf & 2) {
        ɵngcc0.ɵɵadvance(2);
        ɵngcc0.ɵɵproperty("ngIf", ctx.muted || ctx.volume === 0);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.muted && ctx.volume > 0 && ctx.volume < 0.25);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.muted && ctx.volume >= 0.25 && ctx.volume < 0.5);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("ngIf", !ctx.muted && ctx.volume >= 0.5);
        ɵngcc0.ɵɵadvance(1);
        ɵngcc0.ɵɵproperty("color", ctx.color);
    } }, directives: [ɵngcc4.MatButton, ɵngcc1.NgIf, ɵngcc6.MatSlider, ɵngcc5.MatIcon], styles: [".volume-control[_ngcontent-%COMP%]{display:inline}.volume-slider[_ngcontent-%COMP%]{margin-left:-15px} .mat-slider-thumb{border-color:transparent!important} .mat-slider-track-background{background-color:#d3d3d3!important;-webkit-transform:translateX(0)!important;transform:translateX(0)!important}.volume-control[_ngcontent-%COMP%]   .volume-slider[_ngcontent-%COMP%]{visibility:hidden;opacity:0;min-width:0;width:0;transition:visibility .2s,opacity .2s linear,width .2s linear}.volume-control[_ngcontent-%COMP%]:hover   .volume-slider[_ngcontent-%COMP%]{visibility:visible;opacity:1;min-width:90px;width:90px;transition:opacity .2s linear,width .2s linear,min-width .2s linear}"] });
__decorate([
    Input(),
    __metadata("design:type", HTMLVideoElement)
], MatVolumeControlComponent.prototype, "video", void 0);
__decorate([
    Input(),
    __metadata("design:type", String)
], MatVolumeControlComponent.prototype, "color", void 0);
__decorate([
    Input(),
    __metadata("design:type", Number)
], MatVolumeControlComponent.prototype, "volume", void 0);
__decorate([
    Output(),
    __metadata("design:type", Object)
], MatVolumeControlComponent.prototype, "volumeChanged", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], MatVolumeControlComponent.prototype, "muted", null);
__decorate([
    Output(),
    __metadata("design:type", Object)
], MatVolumeControlComponent.prototype, "mutedChanged", void 0);
__decorate([
    Input(),
    __metadata("design:type", Boolean)
], MatVolumeControlComponent.prototype, "keyboard", void 0);
__decorate([
    HostListener('document:keyup.m', ['$event']),
    __metadata("design:type", Function),
    __metadata("design:paramtypes", [KeyboardEvent]),
    __metadata("design:returntype", void 0)
], MatVolumeControlComponent.prototype, "onMuteKey", null);
MatVolumeControlComponent = __decorate([ __metadata("design:paramtypes", [EventService])
], MatVolumeControlComponent);

let MatVideoModule = class MatVideoModule {
};
MatVideoModule.ɵmod = ɵngcc0.ɵɵdefineNgModule({ type: MatVideoModule });
MatVideoModule.ɵinj = ɵngcc0.ɵɵdefineInjector({ factory: function MatVideoModule_Factory(t) { return new (t || MatVideoModule)(); }, providers: [
        FullscreenService,
        EventService
    ], imports: [[
            CommonModule,
            MatIconModule,
            MatButtonModule,
            MatSliderModule,
        ]] });
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(EventService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoComponent, [{
        type: Component,
        args: [{
                selector: 'mat-video',
                template: "<div #player class=\"videoplayer\" [ngClass]=\"getOverlayClass('show-mouse', 'hide-mouse')\">\r\n    <div class=\"header\" *ngIf=\"title\" [ngClass]=\"getOverlayClass('visible', 'hidden')\">\r\n        {{title}}\r\n    </div>\r\n\r\n    <video #video class=\"video\" [attr.src]=\"src ? src : null\" [attr.autoplay]=\"autoplay ? true : null\"\r\n        [preload]=\"preload ? 'auto' : 'metadata'\" [attr.poster]=\"poster ? poster : null\"\r\n        [attr.loop]=\"loop ? loop : null\">\r\n        <ng-content select=\"source\"></ng-content>\r\n        <ng-content select=\"track\"></ng-content>\r\n        This browser does not support HTML5 video.\r\n    </video>\r\n\r\n    <div class=\"controls\" *ngIf=\"videoLoaded\" [ngClass]=\"getOverlayClass('visible', 'hidden')\">\r\n        <div class=\"progress\">\r\n            <mat-seek-progress-control [color]=\"color\" [video]=\"video\"></mat-seek-progress-control>\r\n        </div>\r\n\r\n        <div class=\"menu\">\r\n            <div class=\"left\">\r\n                <mat-play-button (playChanged)=\"playing = $event\" [video]=\"video\" [keyboard]=\"keyboard\">\r\n                </mat-play-button>\r\n\r\n                <mat-frame-by-frame-control *ngIf=\"showFrameByFrame\" [video]=\"video\" [fps]=\"fps\"></mat-frame-by-frame-control>\r\n\r\n                <mat-volume-control [muted]=\"muted\" (mutedChanged)=\"muted = $event; mutedChange.emit(muted);\"\r\n                    [color]=\"color\" [video]=\"video\" [keyboard]=\"keyboard\">\r\n                </mat-volume-control>\r\n\r\n                <mat-time-control [video]=\"video\"></mat-time-control>\r\n            </div>\r\n\r\n            <div class=\"right\">\r\n                <mat-quality-control *ngIf=\"quality\" [video]=\"video\"></mat-quality-control>\r\n\r\n                <mat-download-button *ngIf=\"download\" [title]=\"title\" [video]=\"video\"></mat-download-button>\r\n\r\n                <mat-fullscreen-button *ngIf=\"fullscreen\" (fullscreenChanged)=\"isFullscreen = $event\" [player]=\"player\"\r\n                    [keyboard]=\"keyboard\"></mat-fullscreen-button>\r\n            </div>\r\n        </div>\r\n    </div>\r\n\r\n    <mat-video-spinner [spinner]=\"spinner\" [video]=\"video\"></mat-video-spinner>\r\n</div>\r\n",
                styles: [".videoplayer{font-family:Roboto,\"Helvetica Neue\",sans-serif;background-color:#000;position:relative;width:100%;height:100%}.header{color:#fff;display:flex;justify-content:center;align-items:center;position:absolute;left:0;top:0;padding:14px 0;width:100%;z-index:1;background-image:linear-gradient(to top,rgba(0,0,0,0),rgba(0,0,0,.65))}.video{display:block;width:100%;height:100%;z-index:0}.controls{color:#fff;position:absolute;left:0;bottom:0;width:100%;z-index:1;background-image:linear-gradient(to bottom,rgba(0,0,0,0),rgba(0,0,0,.65))}.controls .progress{height:26px}.controls .menu{display:flex;align-items:center;flex-direction:row;justify-content:space-between;height:48px}.controls .menu .left{justify-content:flex-start}.controls .menu .right{justify-content:flex-end}.visible{visibility:visible;opacity:1;transition:opacity .5s linear}.hidden{visibility:hidden;opacity:0;transition:visibility .5s,opacity .5s linear}.show-mouse{cursor:default}.hide-mouse{cursor:none}", "@font-face{font-family:'Material Icons';font-style:normal;font-weight:400;src:url(https://fonts.gstatic.com/s/materialicons/v36/flUhRq6tzZclQEJ-Vdg-IuiaDsNc.woff2) format('woff2')}::ng-deep.material-icons{font-family:'Material Icons';font-weight:400;font-style:normal;font-size:24px;line-height:1;letter-spacing:normal;text-transform:none;display:inline-block;white-space:nowrap;word-wrap:normal;direction:ltr;font-feature-settings:'liga';-webkit-font-feature-settings:'liga';-webkit-font-smoothing:antialiased}"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { src: [{
            type: Input
        }], title: [{
            type: Input
        }], autoplay: [{
            type: Input
        }], preload: [{
            type: Input
        }], loop: [{
            type: Input
        }], quality: [{
            type: Input
        }], fullscreen: [{
            type: Input
        }], showFrameByFrame: [{
            type: Input
        }], fps: [{
            type: Input
        }], download: [{
            type: Input
        }], color: [{
            type: Input
        }], spinner: [{
            type: Input
        }], poster: [{
            type: Input
        }], keyboard: [{
            type: Input
        }], overlay: [{
            type: Input
        }], muted: [{
            type: Input
        }], mutedChange: [{
            type: Output
        }], timeChange: [{
            type: Output
        }], time: [{
            type: Input
        }], player: [{
            type: ViewChild,
            args: ['player']
        }], video: [{
            type: ViewChild,
            args: ['video']
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoSourceDirective, [{
        type: Directive,
        args: [{
                selector: '[matVideoSource]'
            }]
    }], function () { return [{ type: MatVideoComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }]; }, { src: [{
            type: Input
        }], type: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoTrackDirective, [{
        type: Directive,
        args: [{
                selector: '[matVideoTrack]'
            }]
    }], function () { return [{ type: MatVideoComponent, decorators: [{
                type: Host
            }] }, { type: ɵngcc0.ElementRef }]; }, { src: [{
            type: Input
        }], kind: [{
            type: Input
        }], srclang: [{
            type: Input
        }], label: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSliderProgressBarComponent, [{
        type: Component,
        args: [{
                selector: 'mat-slider-progress-bar',
                template: "<div class=\"mat-slider-wrapper\" #sliderWrapper>\r\n    <div class=\"mat-slider-track-wrapper\">\r\n        <svg width=\"100%\" height=\"2\" focusable=\"false\" class=\"mat-slider-progress-background\">\r\n            <defs>\r\n                <pattern [id]=\"sliderprogressbarId\" x=\"2.5\" y=\"0\" width=\"5\" height=\"2.5\" patternUnits=\"userSpaceOnUse\">\r\n                    <circle cx=\"1.25\" cy=\"1.25\" r=\"1.25\" />\r\n                </pattern>\r\n            </defs>\r\n            <rect [attr.fill]=\"'url(#' + sliderprogressbarId + ')'\" width=\"100%\" height=\"100%\" />\r\n        </svg>\r\n        <div class=\"mat-slider-track-fill mat-slider-track-buffer\" [ngStyle]=\"_trackBufferStyles\"></div>\r\n        <div class=\"mat-slider-track-fill\" [ngStyle]=\"_trackFillStyles\"></div>\r\n    </div>\r\n    <div class=\"mat-slider-ticks-container\" [ngStyle]=\"_ticksContainerStyles\">\r\n        <div class=\"mat-slider-ticks\" [ngStyle]=\"_ticksStyles\"></div>\r\n    </div>\r\n    <div class=\"mat-slider-thumb-container\" [ngStyle]=\"_thumbContainerStyles\">\r\n        <div class=\"mat-slider-focus-ring\"></div>\r\n        <div class=\"mat-slider-thumb\"></div>\r\n        <div class=\"mat-slider-thumb-label\">\r\n            <span class=\"mat-slider-thumb-label-text\">{{displayValue}}</span>\r\n        </div>\r\n    </div>\r\n</div>",
                providers: [MAT_SLIDER_VALUE_ACCESSOR],
                host: {
                    '(focus)': '_onFocus()',
                    '(blur)': '_onBlur()',
                    '(click)': 'this["_onClick"] ? this["_onClick"]($event) : null',
                    '(mousedown)': 'this["_onMousedown"] ? this["_onMousedown"]($event) : null',
                    '(keydown)': '_onKeydown($event)',
                    '(keyup)': '_onKeyup()',
                    '(mouseenter)': '_onMouseenter()',
                    '(slide)': '_onSlide($event)',
                    '(slideend)': '_onSlideEnd()',
                    '(slidestart)': '_onSlideStart($event)',
                    'class': 'mat-slider',
                    'role': 'slider',
                    '[tabIndex]': 'tabIndex',
                    '[attr.aria-disabled]': 'disabled',
                    '[attr.aria-valuemax]': 'max',
                    '[attr.aria-valuemin]': 'min',
                    '[attr.aria-valuenow]': 'value',
                    '[attr.aria-orientation]': 'vertical ? "vertical" : "horizontal"',
                    '[class.mat-slider-disabled]': 'disabled',
                    '[class.mat-slider-has-ticks]': 'tickInterval',
                    '[class.mat-slider-horizontal]': '!vertical',
                    '[class.mat-slider-axis-inverted]': '_invertAxis',
                    '[class.mat-slider-sliding]': '_isSliding',
                    '[class.mat-slider-thumb-label-showing]': 'thumbLabel',
                    '[class.mat-slider-vertical]': 'vertical',
                    '[class.mat-slider-min-value]': '_isMinValue',
                    '[class.mat-slider-hide-last-tick]': 'disabled || _isMinValue && _thumbGap && _invertAxis'
                },
                inputs: ['disabled', 'color', 'tabIndex'],
                changeDetection: ChangeDetectionStrategy.OnPush,
                styles: [":host{width:100%}.mat-slider-progress-background{position:absolute;height:2px;width:100%;fill:#d3d3d3}.mat-slider-track-buffer{background-color:#d3d3d3!important}.mat-slider-thumb{border-color:transparent!important;visibility:hidden;opacity:0;transition:visibility .2s,opacity .2s linear}:host:hover .mat-slider-thumb{visibility:visible;opacity:1;transition:opacity .2s linear}"]
            }]
    }], function () { return [{ type: ɵngcc0.ElementRef }, { type: ɵngcc2.FocusMonitor }, { type: ɵngcc0.ChangeDetectorRef }, { type: ɵngcc3.Directionality, decorators: [{
                type: Optional
            }] }, { type: String, decorators: [{
                type: Attribute,
                args: ['tabindex']
            }] }]; }, { mode: [{
            type: Input
        }], value: [{
            type: Input
        }], bufferValue: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(SecondsToTimePipe, [{
        type: Pipe,
        args: [{
                name: 'secondsToTime'
            }]
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(FullscreenService, [{
        type: Injectable
    }], function () { return []; }, null); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatDownloadButtonComponent, [{
        type: Component,
        args: [{
                selector: 'mat-download-button',
                template: "<a mat-icon-button [href]=\"video?.currentSrc\" [download]=\"title\">\r\n  <mat-icon>file_download</mat-icon>\r\n</a>",
                styles: ["a{color:inherit;text-decoration:none}"]
            }]
    }], function () { return []; }, { video: [{
            type: Input
        }], title: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatFrameByFrameControlComponent, [{
        type: Component,
        args: [{
                selector: 'mat-frame-by-frame-control',
                template: "<button mat-icon-button (click)=\"seekFrames(-5)\">\r\n    <mat-icon>skip_previous</mat-icon>\r\n</button>\r\n\r\n<button mat-icon-button (click)=\"seekFrames(-1)\">\r\n    <mat-icon>arrow_left</mat-icon>\r\n</button>\r\n\r\n<button mat-icon-button (click)=\"seekFrames(1)\">\r\n    <mat-icon>arrow_right</mat-icon>\r\n</button>\r\n\r\n<button mat-icon-button (click)=\"seekFrames(5)\">\r\n    <mat-icon>skip_next</mat-icon>\r\n</button>",
                styles: [""]
            }]
    }], function () { return []; }, { fps: [{
            type: Input
        }], video: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatFullscreenButtonComponent, [{
        type: Component,
        args: [{
                selector: 'mat-fullscreen-button',
                template: "<button mat-icon-button [disabled]=\"!canFullscreen\" (click)=\"toggleFullscreen()\">\r\n  <mat-icon *ngIf=\"!fullscreen\">fullscreen</mat-icon>\r\n  <mat-icon *ngIf=\"fullscreen\">fullscreen_exit</mat-icon>\r\n</button>",
                styles: [""]
            }]
    }], function () { return [{ type: FullscreenService }, { type: EventService }]; }, { fullscreen: [{
            type: Input
        }], fullscreenChanged: [{
            type: Output
        }], keyboard: [{
            type: Input
        }], onFullscreenKey: [{
            type: HostListener,
            args: ['document:keyup.f', ['$event']]
        }], player: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatPlayButtonComponent, [{
        type: Component,
        args: [{
                selector: 'mat-play-button',
                template: "<button mat-icon-button (click)=\"toggleVideoPlayback()\">\r\n  <mat-icon *ngIf=\"!play\">play_arrow</mat-icon>\r\n  <mat-icon *ngIf=\"play\">pause</mat-icon>\r\n</button>",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { play: [{
            type: Input
        }], playChanged: [{
            type: Output
        }], keyboard: [{
            type: Input
        }], onPlayKey: [{
            type: HostListener,
            args: ['document:keyup.space', ['$event']]
        }], video: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatQualityControlComponent, [{
        type: Component,
        args: [{
                selector: 'mat-quality-control',
                template: "<div *ngIf=\"video && video.videoHeight\" class=\"quality\">\r\n  {{ video.videoHeight }}p\r\n</div>",
                styles: [".quality{display:inline-block;font-size:12px;padding-left:12px;padding-right:12px}"]
            }]
    }], function () { return []; }, { video: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatSeekProgressControlComponent, [{
        type: Component,
        args: [{
                selector: 'mat-seek-progress-control',
                template: "<mat-slider-progress-bar [color]=\"color\" mode=\"buffer\" step=\"0.01\" [value]=\"curTimePercent\" [bufferValue]=\"bufTimePercent\"\n  (input)=\"seekVideo($event.value)\"></mat-slider-progress-bar>",
                styles: [""]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { video: [{
            type: Input
        }], color: [{
            type: Input
        }], currentTime: [{
            type: Input
        }], currentTimeChanged: [{
            type: Output
        }], bufferedTime: [{
            type: Input
        }], bufferedTimeChanged: [{
            type: Output
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatTimeControlComponent, [{
        type: Component,
        args: [{
                selector: 'mat-time-control',
                template: "<div class=\"playtime\">\r\n  {{ video?.currentTime | secondsToTime }} / {{ video?.duration | secondsToTime}}\r\n</div>",
                styles: [".playtime{display:inline;font-size:12px}"]
            }]
    }], function () { return []; }, { video: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoSpinnerComponent, [{
        type: Component,
        args: [{
                selector: 'mat-video-spinner',
                template: "<div *ngIf=\"!videoLoaded || videoBuffering\" [class]=\"spinner\"></div>",
                styles: [":host{position:absolute;left:calc(50% - 32px);top:calc(50% - 32px);z-index:1}", ".spin{box-sizing:border-box;width:64px;height:64px;border-radius:100%;border:10px solid rgba(255,255,255,.2);border-top-color:#fff;-webkit-animation:1s linear infinite spin;animation:1s linear infinite spin}@-webkit-keyframes spin{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes spin{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}", ".dot{width:64px;height:64px;background-color:#fff;border-radius:100%;-webkit-animation:1s ease-in-out infinite dot;animation:1s ease-in-out infinite dot}@-webkit-keyframes dot{0%{-webkit-transform:scale(0)}100%{-webkit-transform:scale(1);opacity:0}}@keyframes dot{0%{-webkit-transform:scale(0);transform:scale(0)}100%{-webkit-transform:scale(1);transform:scale(1);opacity:0}}", ".split-ring{display:inline-block;width:64px;height:64px}.split-ring:after{content:\" \";display:block;width:46px;height:46px;margin:1px;border-radius:50%;border:5px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s linear infinite split-ring;animation:1.2s linear infinite split-ring}@-webkit-keyframes split-ring{0%{-webkit-transform:rotate(0)}100%{-webkit-transform:rotate(360deg)}}@keyframes split-ring{0%{-webkit-transform:rotate(0);transform:rotate(0)}100%{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}", ".hourglass{display:inline-block;position:relative;width:64px;height:64px}.hourglass:after{content:\" \";display:block;border-radius:50%;width:0;height:0;margin:6px;box-sizing:border-box;border:26px solid #fff;border-color:#fff transparent;-webkit-animation:1.2s infinite hourglass;animation:1.2s infinite hourglass}@-webkit-keyframes hourglass{0%{-webkit-transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{-webkit-transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{-webkit-transform:rotate(720deg)}}@keyframes hourglass{0%{-webkit-transform:rotate(0);transform:rotate(0);-webkit-animation-timing-function:cubic-bezier(.55,.055,.675,.19);animation-timing-function:cubic-bezier(.55,.055,.675,.19)}50%{-webkit-transform:rotate(360deg);transform:rotate(360deg);-webkit-animation-timing-function:cubic-bezier(.215,.61,.355,1);animation-timing-function:cubic-bezier(.215,.61,.355,1)}100%{-webkit-transform:rotate(720deg);transform:rotate(720deg)}}"]
            }]
    }], function () { return [{ type: ɵngcc0.Renderer2 }, { type: EventService }]; }, { spinner: [{
            type: Input
        }], video: [{
            type: Input
        }] }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVolumeControlComponent, [{
        type: Component,
        args: [{
                selector: 'mat-volume-control',
                template: "<div class=\"volume-control\">\r\n  <button mat-icon-button (click)=\"toggleMuted()\">\r\n    <mat-icon *ngIf=\"muted || volume === 0\">volume_off</mat-icon>\r\n    <mat-icon *ngIf=\"!muted && volume > 0 && volume < 0.25\">volume_mute</mat-icon>\r\n    <mat-icon *ngIf=\"!muted && volume >= 0.25 && volume < 0.5\">volume_down</mat-icon>\r\n    <mat-icon *ngIf=\"!muted && volume >= 0.5\">volume_up</mat-icon>\r\n  </button>\r\n  <mat-slider class=\"volume-slider\" [color]=\"color\" min=\"0\" max=\"1\" step=\"0.01\" value=\"1\" (input)=\"setVolume($event.value)\">\r\n  </mat-slider>\r\n</div>",
                styles: [".volume-control{display:inline}.volume-slider{margin-left:-15px}::ng-deep.mat-slider-thumb{border-color:transparent!important}::ng-deep.mat-slider-track-background{background-color:#d3d3d3!important;-webkit-transform:translateX(0)!important;transform:translateX(0)!important}.volume-control .volume-slider{visibility:hidden;opacity:0;min-width:0;width:0;transition:visibility .2s,opacity .2s linear,width .2s linear}.volume-control:hover .volume-slider{visibility:visible;opacity:1;min-width:90px;width:90px;transition:opacity .2s linear,width .2s linear,min-width .2s linear}"]
            }]
    }], function () { return [{ type: EventService }]; }, { video: [{
            type: Input
        }], color: [{
            type: Input
        }], volume: [{
            type: Input
        }], volumeChanged: [{
            type: Output
        }], mutedChanged: [{
            type: Output
        }], keyboard: [{
            type: Input
        }], muted: [{
            type: Input
        }], onMuteKey: [{
            type: HostListener,
            args: ['document:keyup.m', ['$event']]
        }] }); })();
(function () { (typeof ngJitMode === "undefined" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(MatVideoModule, { declarations: function () { return [SecondsToTimePipe,
        MatVideoComponent,
        MatSliderProgressBarComponent,
        MatPlayButtonComponent,
        MatVolumeControlComponent,
        MatDownloadButtonComponent,
        MatFullscreenButtonComponent,
        MatTimeControlComponent,
        MatQualityControlComponent,
        MatVideoSpinnerComponent,
        MatSeekProgressControlComponent,
        MatVideoSourceDirective,
        MatVideoTrackDirective,
        MatFrameByFrameControlComponent]; }, imports: function () { return [CommonModule,
        MatIconModule,
        MatButtonModule,
        MatSliderModule]; }, exports: function () { return [MatVideoComponent,
        MatVideoSourceDirective,
        MatVideoTrackDirective]; } }); })();
/*@__PURE__*/ (function () { ɵngcc0.ɵsetClassMetadata(MatVideoModule, [{
        type: NgModule,
        args: [{
                declarations: [
                    SecondsToTimePipe,
                    MatVideoComponent,
                    MatSliderProgressBarComponent,
                    MatPlayButtonComponent,
                    MatVolumeControlComponent,
                    MatDownloadButtonComponent,
                    MatFullscreenButtonComponent,
                    MatTimeControlComponent,
                    MatQualityControlComponent,
                    MatVideoSpinnerComponent,
                    MatSeekProgressControlComponent,
                    MatVideoSourceDirective,
                    MatVideoTrackDirective,
                    MatFrameByFrameControlComponent
                ],
                imports: [
                    CommonModule,
                    MatIconModule,
                    MatButtonModule,
                    MatSliderModule,
                ],
                exports: [
                    MatVideoComponent,
                    MatVideoSourceDirective,
                    MatVideoTrackDirective
                ],
                providers: [
                    FullscreenService,
                    EventService
                ]
            }]
    }], null, null); })();

/**
 * Generated bundle index. Do not edit.
 */

export { MatVideoModule, SecondsToTimePipe as ɵa, MatVideoComponent as ɵb, EventService as ɵc, MatSliderProgressBarComponent as ɵd, MatPlayButtonComponent as ɵe, MatVolumeControlComponent as ɵf, MatDownloadButtonComponent as ɵg, MatFullscreenButtonComponent as ɵh, FullscreenService as ɵi, MatTimeControlComponent as ɵj, MatQualityControlComponent as ɵk, MatVideoSpinnerComponent as ɵl, MatSeekProgressControlComponent as ɵm, MatVideoSourceDirective as ɵn, MatVideoTrackDirective as ɵo, MatFrameByFrameControlComponent as ɵp };

//# sourceMappingURL=mat-video.js.map